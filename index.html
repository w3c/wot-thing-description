<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Web of Things (WoT) Thing Description</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
    <script class='remove'>
var respecConfig = {
  specStatus: "ED",
  shortName: "wot-thing-description",
  copyrightStart:       2017,
  noLegacyStyle:        true,
  publishDate:          "",
  previousPublishDate:  "",
  previousMaturity:     "",
  edDraftURI:           "https://w3c.github.io/wot-thing-description/",
  crEnd:                "",
  inlineCSS:            true,
  noIDLIn:              true,
  format:               'markdown',
  editors: [
    { name: "Sebastian Kaebisch", company: "Siemens" },
    { name: "Takuki Kamiya", company: "Fujitsu" },
  ],
  wg:           "Web of Things Working Group",
  wgURI:        "https://www.w3.org/WoT/WG/",
  wgPublicList: "member-wot-wg@w3.org",
  issueBase: "https://www.github.com/w3c/wot-thing-description/issues/",
  githubAPI: "https://api.github.com/repos/w3c/wot-thing-description",
  otherLinks: [
    {
      key: "Repository",
      data: [{
            value: "We are on Github.",
            href: "https://github.com/w3c/wot-thing-description"
        }, {
            value: "File a bug.",
            href: "https://github.com/w3c/wot-thing-description/issues"
        }, {
            value: "Commit history.",
            href: "https://github.com/w3c/wot-thing-description/commits/"
        }, {
            value: "Use cases",
            href: "https://github.com/w3c/wot-thing-description/use-cases.html"
        }
      ]
    },
    {
      key: "Contributors",
      data: [
          {
            value: "In the github repository",
            href: "https://github.com/w3c/wot-thing-description/graphs/contributors"
          }
      ]
    },
  ],
};
    </script>
  </head>
  <body>

  <section id="abstract">
Each Thing is described by a WoT <a>Thing Description</a> (TD).
The TD must be acquired to use and interact with the Thing, since it describes the semantics of a Thing as well as its <a>WoT Interface</a>.
Usually, Things directly provide their own TD, but the TD can also be hosted externally if there is not enough space on the device or when a WoT-compatible legacy device is retrofitted with a TD.
  </section>

  <section id="sotd">
  <p>
    Implementers need to be aware that this specification is considered unstable. Vendors interested in implementing this specification before it eventually reaches the Candidate Recommendation phase should subscribe to the [repository](https://github.com/w3c/wot-thing-description) and take part in the discussions.
  </p>
  </section>

  <section id="introduction">
    <h1>Introduction</h1>
    <p>
The WoT Thing Description (TD) provides the semantic metadata of a Thing as well as a functional description of its <a>WoT Interface</a>.
For this, it relies on the Resource Description Framework (RDF) [[!rdf11-concepts]] as an underlying data model.
For now, [[!JSON-LD]] is used as the default TD serialization format.
The WoT IG defined a minimal vocabulary to express the capabilities of a Thing in terms of different interaction patterns: <i>Properties</i>, <i>Actions</i>, and <i>Events</i>.
In addition, the TD provides metadata for the different communication bindings (e.g., HTTP, CoAP, etc.), mediaTypes (e.g., "application/json", "application/exi", etc.), and security policies (authentication, authorization, etc.).
<a href="#fig-td"></a> gives an overview of the relevant content defined in a TD.
    </p>
    <figure id="fig-td">
<img src="td-concepts.png" style="width:60%" />
<figcaption>Concepts of the Thing Description (TD)</figcaption>
    </figure>
  </section>

  <section id="quick-start">
    <h1>Quick Start: TD Samples</h1>
    <p>
This section gives a brief introduction to the TD as JSON-LD samples.
    </p>

    <p>
In the following, we introduce three minimal TD samples to show the prospects of the W3C Thing Descriptions.
Example 1 shows a simple TD that describes a temperature Thing with the name <i>MyTemperatureThing</i>.

    </p>

    <pre class="example" title="Data Only">
            {
              "@context": ["http://w3c.github.io/wot/w3c-wot-td-context.jsonld"],
              "@type": "Thing",
              "name": "MyTemperatureThing",
              "interactions": [
                {
                  "@type": ["Property"],
                  "name": "temperature",
                  "outputData": {"valueType": { "type": "number" }},
                  "writable": false,
                  "links": [{
                    "href" : "coap://mytemp.example.com:5683/temp",
                    "mediaType": "application/json"
                    }]
                }
              ]
            }
    </pre>

    <p>
  Based on this content, we know there exists one <i>Property</i> interaction resource with the name <i>temperature</i>. In addition, information is provided 
  such as that this Property is accessable over the CoAP protocol with a GET method (see CoAP protocol binding <a href="#protocol-bindings">here</a>) 
  at <code>coap://mytemp.example.com:5683/temp</code> (announced within the endoind structure by the <i>href</i> kye), which will return a number (TD type system) 
  inside a JSON structure (JSON as payload format is announced by the <i>mediaType</i> field). <!-- However, this is missing critical semantic information such as this resource actually represents and what unit this number has.  -->
    </p>
    
    <p>
In practice, a Thing provides further details about what kind of Thing it is and what the interactions mean.
This additional information is the semantic context of the Thing.
JSON-LD provides a means to extend a TD with an external (semantic) context, which allows to reuse existing models, thereby enhancing semantic interoperability.
Through a context, the meaningless strings turn into semantically defined terms that are part of a linkable vocabulary.
Example 2 shows the integration of the <code>sensor</code> namespace and the resulting semantic enrichment of the temperature 
Property with an additional entry within the <code>@type</code> and unit assignment.
    </p>

    <pre class="example" title="Semantic Annotations">
{
"@context": ["http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
       <span style="font-weight: bold; background-color: lightgrey;">{ "sensor": "http://example.org/sensors#" }</span>
      ],
  "@type": "Thing",
  "name": "MyTemperatureThing",
  "interactions": [
    {
      "@type": ["Property",<div style="font-weight: bold;  background-color:lightgrey; display:inline">"sensor:Temperature"</div>],
      "name": "temperature",
      <div style="font-weight: bold;  background-color:lightgrey; display:inline">"sensor:unit": "sensor:Celsius",</div>
      "outputData": {"valueType": { "type": "number" }},
      "writable": false,
      "links": [{
        "href" : "coap://mytemp.example.com:5683/",
        "mediaType": "application/json"
        }]
    }
  ]
}            
    </pre>

    <p>
Example 3 shows a more advanced TD reflecting an LED Thing that supports multiple protocols (CoAP and HTTP), mediaTypes (JSON and EXI), and security 
policies (it requires a <a>JWT</a> for interaction). This example also shows the definition of the endpoint information in a global manner. More precisely, a global defined <i>base</i> URI is valid for defined interaction
resources.  Indivdualiziation of the URI's resource is done by the <i>href</i> key within the interaction definitions.
<!--The Thing also specifies security policies (it requires a <a>JWT</a>) and provides four different interactions (one Property, two Actions, one Event).-->
    </p>

    <pre class="example" title="More Capabilities">
{
  "@context": [
    "http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
    { "actuator": "http://example.org/actuator#" }
  ],
  "@type": "Thing",
  "name": "MyLEDThing",
  "base": "coap://myled.example.com:5683/",
  "security": {
      "cat": "token:jwt",
      "alg": "HS256",
      "as": "https://authority-issuing.example.org"
    },
  "interactions": [
    {
      "@type": ["Property","actuator:onOffStatus"],
      "name": "status",
      "outputData": {"valueType": { "type": "boolean" }},
      "writable": true,
      "links": [{
        "href" : "pwr", 
        "mediaType": "application/exi" 
      },
      {
        "href" : "http://mytemp.example.com:8080/status",
        "mediaType": "application/json"
      }]
    },
    {
      "@type": ["Action","actuator:fadeIn"],
      "name": "fadeIn",
      "inputData": {
        "valueType": { "type": "integer" },
        "actuator:unit": "actuator:ms"
      },
      "links": [{
        "href" : "in", 
        "mediaType": "application/exi" 
      },
      {
        "href" : "http://mytemp.example.com:8080/in",
        "mediaType": "application/json"
      }]                  
    },
    {
      "@type": ["Action","actuator:fadeOut"],
      "name": "fadeOut",
      "inputData": {
        "valueType": { "type": "integer" },
        "actuator:unit": "actuator:ms"
      },
      "links": [{
        "href" : "out", 
        "mediaType": "application/exi" 
      },
      {
        "href" : "http://mytemp.example.com:8080/out",
        "mediaType": "application/json"
      }]                  
    },
    {
      "@type": ["Event","actuator:alert"],
      "name": "criticalCondition",
      "outputData": {"valueType": { "type": "string" }},
      "links": [{
              "href" : "ev",
              "mediaType": "application/exi"
            }]  
    }
  ]
}
    </pre>

    <p>
Based on this TD, one is able to know that a JSON Web Token (JWT) is required to interact with the resources of the Thing.
They are issued by <code>https://authority-issuing.example.org</code> and signed using HMAC SHA-256 (HS256).
The status of the Thing can be requested using a CoAP GET on <code>coap://myled.example.com:5683/pwr</code> (<i>base</i> URI from the global scope endpoint
definition plus the href) or an 
HTTP GET on <code>http://mything.example.com:8080/myled/status</code>. It can also modified using a PUT on the respective URIs, since Property is writable.
The Actions can be invoked through a POST to the resources fadeIn (<code>/in</code> for CoAP and <code>/myled/in</code> for HTTP) and fadeOut (<code>/out</code> 
for CoAP and <code>/myled/out</code> for HTTP) with an integer value in milliseconds serialized as JSON or EXI. Please note, all this protocol 
binding assumptions are explained <a href="#protocol-bindings">here</a>.
MyLEDThing also serves for the CoAP protocol an Event called criticalCondition, which enables clients to be informed about problems (enabled by the CoAP GET with the Observe 
option to <code>coap://myled.example.com:5683/ev</code>). This event sample also shows the local scope definition of the endpoint which 
overwrite global defined endpoint information. Such a mechanism allows to restrict or expand endpoint oppertunities of indivdual interaction resources.
    </p>
  </section>

  <section><h1>Vocabulary</h1><p><i>This section has been automatically generated.</i></p><section><h2>Classes</h2><h3><code>Thing</code></h3><p>An thing is anything (both physical and non-physical) which has a distinct and independent existence. Every thing has a unique identity. (Definition adapted from 
ISO/IEC CC 30141. Information technology - Internet of Things Reference architecutre (IoT RA)). Alternative definition: the abstract concept of a physical entity that can either be a
real-world artifact, such as a device, or a virtual entity that represents physicality, such as a room or group of devices</p><table class="def"><thead><tr><th>Field Name</th><th>Description</th><th>Expected value type</th></tr></thead><tbody><tr><td><code>interaction</code></td><td>Link from a thing to the interaction patterns it provides</td><td><code>InteractionPattern</code></td></tr><tr><td><code>link</code></td><td>Indicates the endpoints from which an interaction pattern is accessible</td><td><code>Link</code></td></tr></tbody></table><h3><code>Action</code></h3><p>The Action interaction pattern targets changes or processes on a Thing that take a certain time to complete (i.e., actions cannot be applied instantaneously like property writes). Examples include an LED fade in, moving a robot, brewing a cup of coffee, etc. Usually, ongoing Actions are modelled as Task resources, which are created when an Action invocation is received by the Thing. (Definition taken from http://w3c.github.io/wot/current-practices/wot-practices#action)</p><table class="def"><thead><tr><th>Field Name</th><th>Description</th><th>Expected value type</th></tr></thead><tbody><tr><td><code>outputData</code></td><td>link to the n-ary class that allows the declaration of the data type and unit of measure provided by an interaction pattern.</td><td><code>DataSchema</code></td></tr><tr><td><code>inputData</code></td><td>link to the n-ary class that allows the declaration of the data type and unit of measure expected by an interaction pattern.</td><td><code>DataSchema</code></td></tr></tbody></table><h3><code>Event</code></h3><p>The Event interaction pattern enables a mechanism to be notified by a Thing on a certain condition. (Description taken from http://w3c.github.io/wot/current-practices/wot-practices#event)</p><table class="def"><thead><tr><th>Field Name</th><th>Description</th><th>Expected value type</th></tr></thead><tbody><tr><td><code>outputData</code></td><td>link to the n-ary class that allows the declaration of the data type and unit of measure provided by an interaction pattern.</td><td><code>DataSchema</code></td></tr></tbody></table><h3><code>Property</code></h3><p>Property provides readable and/or writeable data that can be static (e.g., supported mode, rated output voltage, etc.) or dynamic (e.g., current fill level of water, minimum recorded temperature, etc.).  (Definition taken from http://w3c.github.io/wot/current-practices/wot-practices#property)</p><table class="def"><thead><tr><th>Field Name</th><th>Description</th><th>Expected value type</th></tr></thead><tbody><tr><td><code>outputData</code></td><td>link to the n-ary class that allows the declaration of the data type and unit of measure provided by an interaction pattern.</td><td><code>DataSchema</code></td></tr></tbody></table><h3><code>InteractionPattern</code></h3><p>An interaction in the context of the Web of Things is an exchange of data between a Web client and a Thing. This data can be either given as input by the client, returned as output by the Thing or both. Three interaction patterns have been defined so far: Property, Action and Event. (Definition taken from http://w3c.github.io/wot/current-practices/wot-practices#interaction-patterns)</p><table class="def"><thead><tr><th>Field Name</th><th>Description</th><th>Expected value type</th></tr></thead><tbody><tr><td><code>link</code></td><td>Indicates the endpoints from which an interaction pattern is accessible</td><td><code>Link</code></td></tr></tbody></table></section></section>

  <section>
    <h1>Semantic Metadata</h1>

    <section>
      <h2>TD Context</h2>

  <section>
    <h1>Semantic Metadata</h1>

    <section>
      <h2>TD Context</h2>

<p>
  <a>JSON-LD</a> is a serialization format that adds a semantic layer on top of the JSON specification: the terms that appear in a JSON document
  should be associated with uniquely identified concepts from shared vocabularies. This principle is part of a set of practices to publish data
  on the Web called Linked Data, where concepts are usually identified with URIs and originate from RDF vocabularies.
</p>

<p>
  The association between terms and concept URIs has to be declared in preamble of the JSON document with the keyword <code>@context</code>.
  The expected value for <code>@context</code> can be of different kinds. A first option is to use a JSON object where keys are terms and
  values are concepts URIs, e.g.:

  <pre class="example">
    {
      "@context": {
        "name": "https://w3c.github.io/wot/w3c-wot-td-ontology.owl#name",
        "base": "https://w3c.github.io/wot/w3c-wot-td-ontology.owl#associatedUri",
        "unit": "http://purl.oclc.org/NET/ssnx/qu/qu-rec20#unit",
        "Thing": "https://w3c.github.io/wot/w3c-wot-td-ontology.owl#Thing",
        ...
      }
    }
  </pre>

  It is also possible to declare namespaces in the context instead of terms. In the example above, three of the four URIs have the same prefix:
  <code>http://www.w3c.org/wot/td#</code>. This common part could be given a short name, refered to as a namespace (as in XML). URIs could
  then be shortened by concatenating namespace with <code>:</code> and a local name (anywhere in the JSON-LD document). E.g.:

  <pre class="example">
    {
      "@context": {
        "wot": "https://w3c.github.io/wot/w3c-wot-td-ontology.owl#",
        "name": "wot:name",
        "base": "wot:associatedUri",
        "unit": "http://purl.oclc.org/NET/ssnx/qu/qu-rec20#unit",
        "Thing": "wot:Thing",
        ...
      }
    }
  </pre>
</p>

<p>
  For the sake of reusability, it is also possible to define an external JSON-LD context and simply give its URI as value of <code>@context</code>.
  All JSON terms that are defined in the present document have been put in an external document, available at
  <code>http://w3c.github.io/wot/w3c-wot-td-context.jsonld</code>. It is highly recommended (but not mandatory) to include this standard
  context in a Thing Description. A basic Thing Description would contain the following declaration:

  <pre class="example">
    {
      "@context": "http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
      ...
    }
  </pre>
</p>

<p>
  A third option is to declare an array, in case a single document involves several contexts. Array elements are either objects or strings,
  as explained above. This option proves relevant if one wants to extend the existing TD context without modifying it. For instance:
  <pre class="example">
    {
      "@context": ["http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
                   {"sensor": "http://example.org/sensors#"}],
      ...
    }
  </pre>

  Section <a href="#td-context-extension"></a> provides a more concrete example on that topic.
</p>
    </section>

    <section>
<h2>Security</h2>

<pre class="example">
  {
    ...
    "security": {"cat":"token:jwt", "alg":"HS256", "as":"https://authority-issuing.org"},
    ...
  }
</pre>

The <b>(optional)</b> security field can be used to provide access metadata (self-contained) information of the Thing
for securely transmitting information via all its resources. Also see Section <a href="#security-considerations"></a>.


<p>Here as a example, JSON Web Token (JWT) type is assigned (cat), the corresponding hashing algorithm "HS256" (alg), and
issuing authority of the security token (as).</p>

    </section>

    <section>
      <h2>Thing Metadata</h2>

      <p>A TD will provide some generic metadata vocabularies that can be used, e.g., 
      to assign a name or what kind of protocols does a servient support.</p>
      <pre class="example">
        {
          ...
          "name": "MyLED",
          "base": "coap://myled.example.com:5683/"
          ...
        }
      </pre>

      <p>
        There are three mandatory and one optional (shown as italic text in JSON snippet) vocabulary terms defined 
        within metadata:
      </p>

      <ul>
        <li><b>name:</b> Name of the Thing (string-based)</li>
        <li><b>base: [optional]</b> Define base URI that is valid for all defined local interaction resources. All other URIs in the TD must then be resolved using the algorithm defined in [[!RFC3986]]</li>
        <li><b>security: [optional]</b>
          The security field can be used to provide access metadata (self-contained) information of the Thing
          for securely transmitting information via all its resources. Also see Section <a href="#security-considerations"></a>.
          Above, the security field is used to announce that JSON Web Token (JWT) has to be used to interact with the resources of the Thing.
          Thereby, type is assigned by the cat field, the corresponding hashing algorithm "HS256" by the alg field, and  the issuing authority of the security token by the as field.
        </li>
      </ul>

      <p>
        <b>Note:</b> Besides these pre-defined terms in the TD context, additional characteristics can be
        added such as product ID, firmware version, location, etc. These terms should then appear in the context of the Thing (as detailed in <a href="#td-context"></a>).
      </p>

    </section>
  </section>

  <section>
    <h1>Interaction Patterns</h1>

    <p>
      An interaction in the context of the Web of Things is an exchange of data between a Web client and a Thing.
      This data can be either given as input by the client, returned as output by the Thing or both.
      Three interaction patterns have been defined so far: Property, Action and Event.
    </p>
  
    <section>
      <h3>Property</h3>
  
      <p>
        Property provides readable and/or writeable data that can be static (e.g., supported mode, rated output voltage, etc.) or 
        dynamic (e.g., current fill level of water, minimum recorded temperature, etc.).
      </p>
  
      <pre class="example">
        {
          ...
         "interactions": [
            {
              "@type": ["Property"],
              "name": "temperature",
              "outputData": {"valueType": { "type": "number" }},
              "writable": false,
              "links": [{
                "href" : "coap://mytemp.example.com:5683/temp",
                "mediaType": "application/json"
              }],
              <i>"stability": 10</i>
            },
          ...
        }
      </pre>
  
      <p>
        There are four mandatory and three optional (italic in JSON sample) terms defined for the Property pattern:
      </p>
  
      <ul>
        <li><b>@type:</b> RDF type of the interaction that defines the semantics through a Linked Data vocabulary (Property is the default value)</li>
        <li><b>name:</b> Name of the Property, which can also be used for simple semantic disambiguation</li>
        <li><b>outputData:</b> Which data type is associated with this Property (see <a href="#type-system"></a> for details)</li>
        <li><b>writable:</b> Is this Property writable (<code>true</code>/<code>false</code>)</li>
        <li><b>links:</b> Local link definitions (as array) with href and mediaType definition</li>  
        <li><b>stability: [optional]</b> Expected period in ms the Property value is expected not to change (>0=estimated period; 0=irregular change; -1=static value)</li>
        <li><b>security: [optional]</b>
          Access metadata (self-contained) for protecting this Property and securely transmitting information.
          Compared to the security field that can be found in the <a href="#thing-metadata">Thing metadata</a>, this field here can be used to apply specific security requirements that is only valid for this resource.
        </li>
      </ul>
  
      <p>
        Absolute URIs in <code>hrefs</code> or endoint can point to an external resource that is not hosted on the Thing directly.
        This can be useful to link data into the context of the Thing, for which there is not enough space in the device itself.
        Absolute URIs could also point to a proxy or gateway that allows access to legacy systems that might belong to a Thing that does not have the capability to translate by itself (but provides other, WoT-compatible resources).
        This mechanism is also interesting for virtual Things that combine the services of multiple other Things (e.g., a room lighting servient that has Properties for each individual light, while these linked Properties are hosted directly on those lights).
      </p>
  
      <p>
        If the property is writable (<code>writable=true</code>), then the Property accepts the same format(s) as input as described for its output.
      </p>
  
      <p>
        The stability field provides a hint for caching and polling.
        This value should also be included in the cache control information of protocols, e.g., the Cache-Control header field of HTTP or Max-Age option of CoAP.
      </p>
    </section>
  
    <section>
      <h3>Action</h3>
  
      <p>
        The Action interaction pattern targets changes or processes on a Thing that take a certain time to complete (i.e., actions cannot be applied instantaneously like property writes).
        Examples include an LED fade in, moving a robot, brewing a cup of coffee, etc.
        Usually, ongoing Actions are modelled as Task resources, which are created when an Action invocation is received by the Thing.
      </p>
  
      <pre class="example">
        {
          ...
          "interactions": [
            {
              "@type": ["Action", "actuator:fadeIn"],
              "name": "fadeIn",
              <i>"inputData":</i> {
                "valueType": { "type": "integer" },
                "actuator:unit": "actuator:ms"
              },
              "links": [{
                "href" : "coap://mytemp.example.com:5683/in",
                "mediaType": "application/json"
              }]
            }
          ]
          ...
        }
      </pre>
      <p>There are one mandatory and four optional terms defined within the <code>Action</code> type:</p>
      <ul>
        <li><b>@type:</b> RDF type of the interaction that defines the semantics through a Linked Data vocabulary (Action is the default entry)</li>
        <li><b>name:</b> Name of the Action, which can also be used for simple semantic disambiguation</li>
        <li><b>inputData: [optional]</b>
          The call parameters associated with this Action.
          A <code>valueType</code> field defines the concrete type (see <a href="#type-system"></a> for details).
          Additional characteristics can be given through terms defined in the context metadata (e.g., unit ms from an actuator vocabulary) similar to <a href="#property">Properties</a>).
        </li>
        <li><b>outputData: [optional]</b> Which data is resulting from this Action (same condition as <code>inputData</code> above)</li>
        <li><b>links:</b> Local link definitions (as array) with href and mediaType definition</li>
        <li><b>security: [optional]</b> Access metadata (self-contained) for protecting this Action and securely transmitting information.</li>
      </ul>
  
      <p>
        The hypertext reference (<code>href</code>) field works similar to Properties.
      </p>
  
      <p>
        Usually, invoking an Action results in a response that indicates a new (sub-)resource, where the started Task can be monitored and also controlled:
        Updating this Task resource may allow for modification of the process (e.g., when it is still queued and not started yet, but also during runtime if the process supports that).
        Deleting this Task resource may allow for cancellation of the Action execution.
        Once the Task completes, the (sub-)resource may be removed by the server; or it is marked as completed, but kept for traceability.
        It is also possible that calling an action produces a so-called action result that is not manifested in any temporary resource nor other changes to the server (e.g., a conversion process or dry run).
      </p>
    </section>
  
    <section>
      <h3>Event</h3>
  
      <p>
        The <code>Event</code> interaction pattern enables a mechanism to be notified by a Thing on a certain condition.
        While some protocols such as CoAP can provide such a mechanism natively, others do not.
        Furthermore, Events might need a specific configuration that requires data sent and stored on the Thing in a standard way.
        There are are two mandatory and two optional terms defined within the <code>Event</code> pattern:
      </p>
  
      <pre class="example">
        {
          ...
          "interactions": [
            {
              "@type": ["Event", "actuator:alert"],
              "name": "criticalCondition",
              "outputData": {"valueType": { "type": "string" }},
              "links": [{
                "href" : "coap://mytemp.example.com:5683/ev",
                "mediaType": "application/json"
              }]
            }
          ]
          ...
        }
      </pre>
  
      <ul>
        <li><b>@type: [optional]</b> RDF type of the interaction that defines the semantics through a Linked Data vocabulary</li>
        <li><b>name:</b> Name of the Event, which can also be used for simple semantic disambiguation</li>
        <li><b>links:</b> Local link definitions (as array) with href and mediaType definition</li>
        <li><b>outputData: [optional]</b> Configuration data associated with this Event. This field works similar to the one of the Action pattern.</li>
        <li><b>security: [optional]</b> Access metadata (self-contained) for protecting this Event and securely transmitting information.</li>
      </ul>
  
      <p class="ednote">
        So far, the concept of events has not been evaluated yet during the PlugFests.
        Thus, there has been little discussion and no common practice has emerged.
        The following text is a proposal to trigger discussion.
      </p>
  
      <p>
        The interaction with Events works similar to Actions with the difference that no side effects are intended on the Thing.
        A client issues a request to the URI of an Event, which may include a payload that represents the configuration data for the Event mechanism.
        Upon reception, the Thing creates a (sub-)resource, which serves as a handle for the Event subscription.
        It can be monitored to receive notifications: an HTTP client would need to poll this resource, while a CoAP client would simply observe it.
        Technically, multiple clients could use the subscription resource created by another client when they are interested in the same Event configuration.
        The Event configuration can also be updated and ultimatively deleted to clean up internal notification hooks.
      </p>
    </section>




  </section>

  <section>
    <h1>Type System</h1>

    <p>All of the three interaction types <code>Property</code>, <code>Action</code>, and <code>Event</code> can specify the type of the value acceptable as an input or expected as an output of the interaction. JSON schema [[!draft-zyp-json-schema-04]] [[!draft-fge-json-schema-validation-00]] provides a standard way to describe the structure and datatypes of data, and we use JSON schema as the notation for value types of the interaction types.
    </p>

    <p>
      <b>Note:</b> In the embodiment of type system described in this section, JSON schema is used as an abstract description system for structured data. 
      JSON schema is something that is already out there being used and well-known, therefore gives us a chance to get started quickly to experiment with type system idea for further contemplation. 
      Through discussion, the following points have been noted as feedback for improvements.
      <ul>
        <li>JSON schema specification was designed for JSON, therefore, may not be an optimal solution as an encoding-neutral description system.</li>
        <li>JSON schema does not provide a way to associate data elements with citations or semantic concepts defined elsewhere.</li>
        <li>JSON schema is relatively verbose.</li>
      </ul>
      Note that there is an idea (<a href="https://github.com/w3c/web-of-things-framework/blob/master/documents/types.md">Proposal for the type system for Things</a>) that was incubated independently and
      was put forward to the IG for consideration.
    </p>

    <p>For <code>Property</code> and <code>Event</code> interaction types, each property or event can specify its value type using <code>valueType</code> with JSON schema definition as its content. The following is an example value type definition. In the example, <code>temperature</code> property and <code>criticalCondition</code> event are defined as  <code>number</code> and <code>string</code>, respectively.
    </p>

    <pre class="example">
      {
        ...
        "properties": [
          {
            ...
            "name": "temperature",
            "valueType": { "type": "number" },
            ...
          }
        ]
        ...
        "events": [
          {
            ...
            "name": "criticalCondition",
            "valueType": { "type": "string" },
            ...
          }
        ]
        ...
      }
    </pre>

    <p>Similarly, for <code>Action</code> interaction type, each action can specify its input and/or output value type using <code>valueType</code> with JSON schema definition as its content. The following is an example value type definition for an action. In the example, <code>fadeIn</code> action is defined to have <code>inputData</code> of type <code>number</code> and <code>outputData</code> of type <code>boolean</code>.
    </p>

    <pre class="example">
      {
        ...
        "actions": [
          {
            ...
            "name": "fadeIn",
            "inputData": {
              "valueType": { "type": "number" },
              "actuator:unit": "actuator:ms"
            },
            "outputData": {
              "valueType": { "type": "boolean" },
            },
            ...
          }
        ]
        ...
      }
    </pre>

    <section>
      <h4>Simple Data</h4>
      <p>With value types described by means of JSON schema, serialization of data exchanged between servients is straightforward when it is in JSON format.
      </p>
  
      <p>Consider the following <code>valueType</code> definition which defines the value to be a <code>number</code> within the value range of [ 0 ... 255 ].
      </p>
  
      <pre class="example">
        "valueType": { 
          "type": "number",
          "minimum": 0,
          "maximum": 255,
        }
      </pre>
  
      <p>When the <code>number</code> being exchanged is 123, data serialization in JSON format will look like the following.
      </p>
  
      <pre class="example">
        { "value": 123 }
      </pre>
  
      <p>The same data (i.e. a number of 123) will look like the following when the data is exchanged in XML.
      </p>
  
      <pre class="example">
          &lt;number>123&lt;/number>
      </pre>
  
      <p class="note" title="Wrapping single values in a JSON object">
        At the time of this writing, some JSON parsers and serializers seem to have problems with value-only literals. Also, whether a single literal such as "hello" is itself a valid JSON instance depends on the JSON specification (RFC vs. ECMA). Therefore, wrapping the value with a top-level object seems to be prudent.
      </p>
    </section>
  
    <section>
      <h4>Structured Data</h4>
  
      <p>In the previous section, we used an example <code>valueType</code> definition consisting of a single <code>number</code>.
      </p>
  
      <p>Since we are using JSON schema to describe <code>valueType</code>, it is also possible to define value types that have more than one literal value.
      JSON provides two distinct constructs to define a structure that can have multiple literal values. 
      One is JSON object, and the other is JSON array.
      </p>
  
      <section>
        <h5 id="json-object">JSON Object</h5>
    
        <p>The following is an example <code>valueType</code> definition that defines the value to be an <code>object</code> that consists of
        two named literals  <code>id</code> (of type <code>integer</code>) and <code>name</code> (of type <code>string</code>)
        where <code>id</code> is required to be present.
        </p>
    
        <pre class="example">
          "valueType": {
              "type": "object",
              "properties": {
                  "id": {
                      "type": "integer"
                  },
                  "name": {
                      "type": "string"
                  }
              },
              "required": ["id"]
          }
        </pre>
    
        <p>When the <code>id</code> number and the <code>name</code> string values being exchanged are 12345 and "Web of Things", data serialization in JSON format will look like the following.
        </p>
    
        <pre class="example">
          {
            "value": {
              "id": 12345,
              "name": "Web of Things"
            }
          }
        </pre>
    
        <p>The above data will look the following when the data is exchanged in XML.
        </p>
    
        <pre class="example">
            &lt;object>
              &lt;id>
                &lt;number>12345&lt;/number>
              &lt;/id>
              &lt;name>
                &lt;string>Web of Things&lt;/string>
              &lt;/name>
            &lt;/object>
        </pre>
    
        <div class="note" title="RDF serialization of value types">
          <p>
            Using the TD model and JSON Schema in a single document may lead
            to a name conflict:
            <code>properties</code> is used both to declare Properties of the Thing and expected keys in a JSON object.
             Depending on the use case, if a serialization of the Thing
            Description in RDF is required, the <code>valueType</code>
            definition should be processed with an additional JSON-LD
            context that overrides the mapping for <code>properties</code>
            (see [[!JSON-LD]], Advanced Context Usage).
          </p>
        </div>
    
      </section>
  
      <section>
        <h5 id="json-array">JSON Array</h5>
    
        <p>The following is an example <code>valueType</code> definition that defines the value to be an <code>array</code> that consists of
        exactly three number literals with each value within the range of [ 0 ... 255 ].
        </p>
    
        <pre class="example">
          "valueType": {
              "type": "array",
              "items": {
                  "type" : "number",
                  "minimum": 0,
                  "maximum": 255
              },
              "minItems" : 3,
              "maxItems" : 3
          }
        </pre>
    
        <p>When the numbers being exchanged are 208, 32 and 144, data serialization in JSON format will look like the following.
        </p>
    
        <pre class="example">
          {
            "value": [
              208,
              32,
              144
            ]
          }
        </pre>
    
        <p>The above data will look the following when the data is exchanged in XML.
        </p>
    
        <pre class="example">
            &lt;array>
              &lt;number>208&lt;/number>
              &lt;number>32&lt;/number>
              &lt;number>144&lt;/number>
            &lt;/array>
        </pre>
    
    
      </section><!-- End of "JSON Array" -->
  
    </section><!-- End of "Structured Data" -->
  
    <section>
    <h4>Mapping to XML Schema</h4>

    <p>In the previous section, examples showed what those data whose <code>valueType</code> are described using JSON schema
    look like when serialized to XML in parallel to corresponding JSON serializations.
    </p>

    <p>This section describes how JSON schema definitions can be mapped to XML schema definitions by using the same examples.
    Given JSON schema definitions, providing the mapping to XML schema allows XML tools to directly validate serialized XML data, for example.
    </p>

    <p>The XML structure is based on EXI4JSON [[!exi-for-json]].
    The structure works uniformly well for both schema-less and schema-informed use cases. 
    </p>

    <p class="ednote">A complete "JSON Schema" to "XML Schema" mapping needs to be defined. 
    </p>

    <section>
      <h5>JSON Object Definition to XML Schema</h5>

      <p>Shown below is the JSON schema <code>object</code> definition used as the <code>valueType</code> in Section <a href="#json-object">JSON Object</a>. The <code>object</code> consists of two named literals <code>id</code> (of type <code>integer</code>) and <code>name</code> (of type <code>string</code>) where <code>id</code> is required to be present.
      </p>

      <pre class="example">
        {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                }
            },
            "required": ["id"]
        }
      </pre>

      <p>When the <code>object</code> is anonymous (i.e. it is the root, or participates in an <code>array</code> definition), 
      the above <code>object</code> definition transforms to the following XML Schema element definition.
      </p>

      <pre class="example">
        &lt;xs:element name="object" xmlns:xs="http://www.w3.org/2001/XMLSchema">
            &lt;xs:complexType>
                &lt;xs:all>
                    &lt;xs:element name="id">
                        &lt;xs:complexType>
                          &lt;xs:sequence>
                            &lt;xs:element name="integer" type="xs:integer" />
                          &lt;/xs:sequence>
                        &lt;/xs:complexType>
                    &lt;/xs:element>
                    &lt;xs:element name="name" minOccurs="0">
                        &lt;xs:complexType>
                          &lt;xs:sequence>
                            &lt;xs:element name="string" type="xs:string" />
                          &lt;/xs:sequence>
                        &lt;/xs:complexType>
                    &lt;/xs:element>
                &lt;/xs:all>
            &lt;/xs:complexType>
        &lt;/xs:element>
        </pre>
  
        <p class="ednote">JSON schema <code>object</code> does NOT define any order. 
        Therefore, in order to capture the constraints of JSON schema <code>object</code>, 
        we need to use xsd:all constructs instead of xsd:sequence.
        </p>
  
        <p>Otherwise (i.e. the <code>object</code> is a member of another <code>object</code> definition, thus has a name), 
        the <code>object</code> definition transforms to the following XML schema element definition.
        Note <code><i>__name</i></code> should be replaced by the actual name of the <code>object</code>.
        </p>
  
        <pre class="example">
          &lt;xs:element name="<i>__name</i>" xmlns:xs="http://www.w3.org/2001/XMLSchema">
              &lt;xs:complexType>
                  &lt;xs:sequence>
                      &lt;xs:element name="object">
                          &lt;xs:complexType>
                              &lt;xs:all>
                                  &lt;xs:element name="id">
                                      &lt;xs:complexType>
                                        &lt;xs:sequence>
                                          &lt;xs:element name="integer" type="xs:integer" />
                                        &lt;/xs:sequence>
                                      &lt;/xs:complexType>
                                  &lt;/xs:element>
                                  &lt;xs:element name="name" minOccurs="0">
                                      &lt;xs:complexType>
                                        &lt;xs:sequence>
                                          &lt;xs:element name="string" type="xs:string" />
                                        &lt;/xs:sequence>
                                      &lt;/xs:complexType>
                                  &lt;/xs:element>
                              &lt;/xs:all>
                          &lt;/xs:complexType>
                      &lt;/xs:element>
                  &lt;/xs:sequence>
              &lt;/xs:complexType>
          &lt;/xs:element>
        </pre>
  
      </section><!-- End of "JSON Object Definition to XML Schema" -->

      <section>
        <h5>JSON Array Definition to XML Schema</h5>
  
        <p>Shown below is the JSON schema <code>array</code> definition used as the <code>valueType</code> in Section <a href="#json-array">JSON Array</a>. 
        The <code>array</code> consists of exactly three number literals with each value within the value range of [ 0 ... 255 ].</p>
  
        <pre class="example">
          {
              "type": "array",
              "items": {
                  "type" : "number"
                  "minimum": 0,
                  "maximum": 255,
              },
              "minItems" : 3,
              "maxItems" : 3
          }
        </pre>
  
        <p>When the <code>array</code> is anonymous (i.e. it is the root, or participates in another <code>array</code> definition), 
        the above <code>array</code> definition transforms to the following XML Schema element definition.
        </p>
  
        <pre class="example">
          &lt;xs:element name="array" xmlns:xs="http://www.w3.org/2001/XMLSchema">
              &lt;xs:complexType>
                  &lt;xs:sequence>
                      &lt;xs:element name="double" minOccurs="3" maxOccurs="3">
                          &lt;xs:simpleType name="minInclusive">
                              &lt;xs:restriction base="xs:double">
                                  &lt;xs:minInclusive value="0"/>
                                  &lt;xs:maxInclusive value="255"/>
                              &lt;/xs:restriction>
                          &lt;/xs:simpleType>
                      &lt;/xs:element>
                  &lt;/xs:sequence>
              &lt;/xs:complexType>
          &lt;/xs:element>
        </pre>
  
        <p>Otherwise (i.e. the <code>array</code> is a member of an <code>object</code> definition, thus has a name), 
        the <code>array</code> definition transforms to the following XML schema element definition.
        Note <code><i>__name</i></code> should be replaced by the actual name of the <code>array</code>.
        </p>
  
  
        <pre class="example">
          &lt;xs:element name="<i>__name</i>" xmlns:xs="http://www.w3.org/2001/XMLSchema">
              &lt;xs:complexType>
                  &lt;xs:sequence>
                      &lt;xs:element name="array">
                          &lt;xs:complexType>
                              &lt;xs:sequence>
                                  &lt;xs:element name="double" minOccurs="3" maxOccurs="3" >
                                      &lt;xs:simpleType name="minInclusive">
                                          &lt;xs:restriction base="xs:double">
                                              &lt;xs:minInclusive value="0"/>
                                              &lt;xs:maxInclusive value="255"/>
                                          &lt;/xs:restriction>
                                      &lt;/xs:simpleType>
                                  &lt;/xs:element>
                              &lt;/xs:sequence>
                          &lt;/xs:complexType>
                      &lt;/xs:element>
                  &lt;/xs:sequence>
              &lt;/xs:complexType>
          &lt;/xs:element>
        </pre>
  
      </section><!-- End of "JSON Array Definition to XML Schema" -->

    </section><!-- End of "Mapping to XML Schema" -->

  </section>

  <section>
    <h1>TD Examples</h1>

    <p>
      In the following, we give three examples of a full TD. The first one, a
      temperature sensor, shows how to define relations between Thing
      Properties. As a second example, we modeled
      an actuator (LED lamp) where Actions have all been characterized semantically,
      so that machines could unambiguously interpret them in an automated manner.
      At last, association between Things is shown by defining a master switch
      controlling other LED lamps.
    </p>

    <section>
      <h4>Temperature Sensor</h4>

      <pre class="example">
        {
          "@context": ["https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
                       "https://w3c.github.io/wot/w3c-wot-common-context.jsonld"],
          "@type": "Sensor",
          "name": "myTempSensor",
         "base" : "coap:///www.example.com:5683/temp/",
          "interactions": [
            {
              "@id": "val",
              "@type": ["Property","Temperature"],
              "unit": "celsius",
              "reference": "threshold",
              "name": "myTemp",
              "outputData": {"valueType": { "type": "number" }},
              "writable": false,
              "links": [{
                "href" : "val",
                "mediaType": "application/json"
              }]
            }, {
              "@id": "threshold",
              "@type": ["Property","Temperature"],
              "unit": "celsius",
              "name": "myThreshold",
              "outputData": {"valueType": { "type": "number" }},
              "writable": true,
               "links": [{
                "href" : "thr",
                "mediaType": "application/json"
              }]
            },
            {
              "@type": ["Event"],
              "outputData": {"valueType": { "type": "number" }},
              "name": "myChange",
              "property": "temp",
              "links": [{
                "href" : "val/changed",
                "mediaType": "application/json"
              }]
            }, {
              "@type": ["Event"],
              "outputData": {"valueType": { "type": "number" }},
              "name": "myWarning",
              "links": [{
                "href" : "val/high",
                "mediaType": "application/json"
              }]
            }
          ]
        }
      </pre>

      <p>
        The Thing <code>myTempSensor</code> defines two Properties: <code>myTemp</code>
        and <code>myThreshold</code>. Both are defined as temperatures, with the same unit
        (<code>celsius</code>). A client that is able to parse a TD only needs to know
        the predicate <code>reference</code> to understand that the threshold acts as
        a reference value for <code>myTemp</code> while the latter is the actual
        value measured by the temperature sensor. Here, <code>reference</code> points
        to <code>http://schema.org/valueReference</code>.
      </p>

      <p>
        Moreover, one of the Events of the Thing is linked to the measured value
        (with the predicate <code>property</code>). It means
        in that context that an event should be triggered each time <code>myTemp</code>
        changes. The other Event does not define further semantics, it could be used either
        in a closed system (where clients are aware of its meaning) or by a human but
        an external agent would not have sufficient information to interpret it.
      </p>
    </section>
    <section>
      <h4>LED Master Switch</h4>
      <pre class="example">
        {
          "@context": ["https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
                       "https://w3c.github.io/wot/w3c-wot-common-context.jsonld"],
          "@type": "Lamp",
          "name": "myMasterLED",
          "interactions": [
            {
              "@type": ["Actions", "Toggle"],
              "name": "myMasterOnOff",
              "inputData": {
                "@type": "OnOff",
                "valueType": { "type": "boolean" }
              },
              "links": [
              {
                "href" : "coap://www.example.com:5683/master",
                "mediaType": "application/json"
              },{
                "href" : "http://www.example.com:80/master",
                "mediaType": "application/json"
              }]
            }
          ],
          "associations": [
            { "hrefs": ["coap://www.example.com:5683/0"] },
            { "hrefs": ["coap://www.example.com:5683/1"] },
            { "hrefs": ["coap://www.example.com:5683/2"] },
            { "hrefs": ["coap://www.example.com:5683/3"] },
            { "hrefs": ["coap://www.example.com:5683/4"] },
            { "hrefs": ["coap://www.example.com:5683/5"] },
            { "hrefs": ["coap://www.example.com:5683/6"] },
            { "hrefs": ["coap://www.example.com:5683/7"] }
          ]
        }
      </pre>

      <p>
        In this last example, we illustrate the use of <code>associations</code>.
        The Thing we modeled here acts as a master switch for eight lamps similar
        to that of <a href="#led-actuator"></a>. It means switching on and off
        <code>myMasterOnOff</code> will propagate to all associated Things
        by toggling their Action that is also of type <code>Toggle</code>.
      </p>

      <p>
        No precise semantics for <code>associations</code> have been defined yet
        and there might exist many other kinds of dependency between Things than
        simply parent/child relation. This issue will be addressed soon. Until then,
        Thing associations could be useful for discovery.
      </p>
    </section>

  </section>

  <section>
    <h1>Usage</h1>

    <section id="td-context-extension">
      <h4>Extending Thing Description with Other Semantic Models</h4>

      <p>
        As the TD context we have developed is intended to be minimal, it is strongly recommended to extend it for each Thing by
        reusing other vocabularies or ontologies and/or defining application-specific terms. In the following example, in addition
        to our standard context, the context of the Thing declares a namespace pointing to a shared vocabulary for domotics called
        <a href="http://elite.polito.it/ontologies/dogont.owl">DogOnt</a>:

        <pre class="example">
          {
            "@context": ["http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
                         {"dogont": "http://elite.polito.it/ontologies/dogont.owl#"}],
            ...
          }
        </pre>

        DogOnt defines hundreds of concepts ranging from HVAC to units of measurement.
      </p>

      <p>
        During early experimentations with TD files, a few concepts and terms
        appeared to be recurrent, such as <code>Temperature</code>, <code>Toggle</code>
        or <code>unit</code>. To ease experimentation with the modeling
        of Things, a context that gathers such common terms has been
        defined at <code>http://w3c.github.io/wot/w3c-wot-common-context.jsonld</code>.
        Its content simply defines aliases for classes and properties of well-known
        ontologies that are relevant for our activity:
        <a href="http://elite.polito.it/ontologies/dogont.owl">DogOnt</a>,
        <a href="http://purl.oclc.org/NET/ssnx/qu/qu">Quantity Kinds &amp; Units</a>,
        <a href="http://linkedgeodata.org/ontology/">LinkedGeoData</a> and
        <a href="http://schema.org/">Schema.org</a>. This file will likely be frequently
        updated and is not intended to become a reference. It should always be used
        along with the standard TD context, as follows:

        <pre class="example">
          {
            "@context": ["http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
                         "http://w3c.github.io/wot/w3c-wot-common-context.jsonld"],
            ...
          }
        </pre>
      </p>

      @TODO more details on contextual semantics (e.g., domain independent and dependant semantic models, ontologies etc.).
    </section>
    
    <section id="td-discovery">
      <h4>Discovery</h4>

      <p class="ednote">
        This section describes in general how a Thing (i.e., its TD) can be discovered.
        In particular, the current practices at the PlugFests should become clear.
        Technology-specific mechanisms such as BLE Beacons or UPnP multicast requests should go into the corresponding sub-sections of <a href="#protocol-bindings"></a>.
      </p>
  
      <p>
        Discovering a Thing means acquiring a link to its TD, which then contains all the information to interact with it and understand its data.
        The URI of the link may point to the Thing (technically the <a>servient</a>) itself, as Things often host their TD directly, or to any other location on the Web.
        There are several approaches to aquire such links.
        Some work independent from the <a>Protocol Binding</a>, others rely on features of a specific protocol.
      </p>
  
      <section>
        <h5>Manual Discovery</h5>
  
        <p>
          The link to the TD is provided by the developer at programming time, the operator through device management, or the user through a UI.
        </p>
      </section>
  
      <section>
        <h5>Repository</h5>
  
        <p>
          The Thing (or a commissioning tool) registers the TD with a well-known repository, which also provides a look-up mechanism (potentially supporting filtering).
        </p>
        <img src="discovery_repository.png" style="width:60%" />
        <p>
          The figure shows the basic concept of the usage of a repository: 1) A servient register its TD to a known TD repository. 2) Another servient does a lookup/search/querying (e.g., via SPARQL) at the TD repository. 3) The repository answers with one ore more relevant TDs. Also a subset of TDs content can be in the result set (e.g., only relevant properties, actions, and/or events are included). 4) Based on the repositorys result set, a connection can be initiated. 

        </p>
      </section>
  
      <section>
        <h5>Local Discovery</h5>
  
        <p>
          The Thing is able to broadcast a discovery request locally (e.g., a CoAP multicast request for <code>/.well-known/core</code>) or to receive announcements from its proximity (e.g., BLE Beacons).
          The response to a discovery request can include the TD directly or just a link.
          For announcements, it is more common to only provide a link, since broadcasting TDs can be expensive.
        </p>
      </section>
    </section>
    
    <section>
      <h4>Security</h4>
      
      @TODO Add howto about security metadata and how to use it
    </section>

  </section>


  </body>
</html>
