<!doctype html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Simplified WoT Thing Description</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
    <script class="remove">
      var respecConfig = {
        specStatus: "ED",
        processVersion: 2017,
        shortName: "wot-thing-description-simplified",
        wg: "Web of Things Working Group",
        wgURI: "https://www.w3.org/WoT/WG/",
        edDraftURI: "https://w3c.github.io/wot-thing-description/proposals/simplified-json-ld/index.html",
        publishDate: "2018-05-23",
        editors: [
          {
            name: "Matthias Kovatsch",
            company: "Siemens AG"
          },
          {
            name: "Sebastian Kaebisch",
            company: "Siemens AG"
          },
          {
            name: "Victor Charpenay",
            company: "Siemens AG"
          }
        ],
        charterDisclosureURI: "https://www.w3.org/2016/07/wot-wg-charter.html#patentpolicy",
        otherLinks: [
          {
            key: "Repository",
            data: [
              {
                value: "We are on GitHub",
                href: "https://github.com/w3c/wot-thing-description/tree/master/proposals/simplified-td"
              },
              {
                value: "File a bug",
                href: "https://github.com/w3c/wot-thing-description/issues"
              }
            ]
          }
        ]
      };
    </script>
    <style>
      table {
        width: 100%;
        border: solid 1px #005a9c;
        border-collapse: collapse;
      }
      th {
        background-color: #005a9c;
        color: white;
      }
      td,
      th {
        border: solid 1px #005a9c;
        padding: 4px;
      }
    </style>
  </head>
  <body>
    <p class="note">Proposal Status: Rejected</p>
    <section id="abstract">
      <p>
        This document summarizes the discussions on simplifying the JSON-LD&nbsp;1.0-based
        <a href="https://www.w3.org/TR/2018/WD-wot-thing-description-20180405/">WoT Thing Description</a> and proposes a
        simplified TD serialization based on <a href="https://json-ld.org/spec/latest/json-ld/">JSON-LD&nbsp;1.1</a>.
        The proposal lists the features of the TD core model and gives use cases per feature. The proposed "Simplified
        TD" serialization is given in the form of extensive examples. Specification text will be added when merging this
        proposal into the WoT Thing Description
        <a href="https://w3c.github.io/wot-thing-description/">Editors' Draft</a>. For convenience, examples of the
        JSON-LD&nbsp;1.0 serialization and the alternative
        <a href="https://w3c.github.io/wot/proposals/json-td/index.html">JSON Web Thing Description</a> (a.k.a. JSON-TD)
        are given for comparison. This document concludes with a list of differences in the proposals.
      </p>
    </section>

    <section id="sotd">
      <p></p>
    </section>

    <section>
      <h1>Introduction</h1>
      <p>
        The <a href="https://www.w3.org/TR/2018/WD-wot-thing-description-20180405/">WoT Thing Description</a> based on
        JSON-LD&nbsp;1.0 has been criticized for several limitations including complexity and the JSON-LD&nbsp;1.0 array
        structures and keywords even when no semantic annotations are used. This lead to an alternative draft, the
        <a href="https://w3c.github.io/wot/proposals/json-td/index.html">JSON Web Thing Description</a>, with a pure
        JSON serialization, which however, would fragment W3C WoT due to incompatible models behind the serializations.
        To remedy the situation, this document proposes a simplified TD serialization based on
        <a href="https://json-ld.org/spec/latest/json-ld/">JSON-LD&nbsp;1.1</a>, thereby combining both requirements:
        machine-understandability through a formal Linked Data model from the original WoT Thing Description and
        improved usability from the JSON Web Thing Description. Being able to conduct these simplifications first
        required a full understanding of the requirements, which have been analyzed by the Working Group since its
        chartering. This technical deep-dive completed around TPAC 2017 (Burlingame), where the Working Group announced
        to change the goal toward simplification from there onward.
      </p>
    </section>

    <section>
      <h1>Use Cases per TD Feature</h1>
      <p>
        Many discussions are rooted on the question whether a certain feature should be included or not. This section
        lists the features currently included in the
        <a href="https://www.w3.org/TR/2018/WD-wot-thing-description-20180405/#overview">TD core model</a> and backs
        them by use cases.
      </p>

      <section>
        <h2>Interaction Model</h2>
        <p>
          To represent a contract between applications with programming APIs and IoT devices with network APIs, the
          communication with Things must be modeled with a formal interaction model. This describes not only
          <emph>what</emph> data a Thing provides or requires, but also <emph>how</emph> to access and manipulate the
          corresponding internal state of a Thing.
        </p>
        <p>
          Based on the <a href="https://www.w3.org/Submission/wot-model/">Web Thing Model</a> and results of the
          <a href="http://www.compose-project.eu/">COMPOSE project</a>
          the WoT Interest Group explored a threefold of Interactions, which was adopted by the WoT Working Group after
          2 years of stability:
        </p>
        <section>
          <h3>Properties</h3>
          <p>
            Properties expose internal state of a Thing that can be directly accessed (get) and optionally manipulated
            (set). Things can also choose to make Properties observable by pushing the new state (not an event) after a
            change; this must follow eventual consistency (also see
            <a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP Theorem</a>).
          </p>
          <ul>
            <li>
              Read-only Properties: state cannot be changed from the outside
              <ul>
                <li>sensors</li>
                <li>results computed from internal state</li>
              </ul>
            </li>
            <li>
              Writable Properties: state needs to be changed directly from the outside
              <ul>
                <li>configuration state</li>
                <li>setpoints</li>
                <li>
                  more concise model when intended state can be applied to actual state immediately (no Action needed)
                </li>
              </ul>
            </li>
            <li>
              Observable Properties: optimize communication through server push
              <ul>
                <li>keep state in sync with relaxed consistency (eventual consistency)</li>
                <li>directly maps to CoAP Observe</li>
              </ul>
            </li>
            <li>
              TODO: Recursive Properties: address sub-properties of a complex Property (to be done for Simplified TD)
              <ul>
                <li>nested Properties that are also exposed by the Thing (e.g., LWM2M Devices/IPSO Objects)</li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h3>Actions</h3>
          <p>
            Actions offer functions of the Thing. These functions may manipulate the interal state of a Thing in a way
            that is not possible through setting Properties. Examples are changing internal state that is not exposed as
            Property, changing multiple Properties, changing Properties over time or with a process that shall not be
            disclosed. Actions may also be pure functions, that is, they do not use any internal state at all, e.g., for
            processing input data and returning the result directly.
          </p>
          <ul>
            <li>
              Action arguments: the function needs input parameters
              <ul>
                <li>write-multiple commands</li>
                <li>functions with parameters</li>
              </ul>
            </li>
            <li>
              Action results: the function returns a result
              <ul>
                <li>read-multiple commands (e.g., CoAP FETCH)</li>
                <li>sensors that are not based on sampling / fit for Properties (e.g., power-intensive sensors)</li>
                <li>function reports (e.g., calibration Action)</li>
                <li>processing functions (e.g., data conversion)</li>
              </ul>
            </li>
            <li>
              TODO: Monitorable Actions: process can be monitored, changed, canceled once invoked (not in TD core model
              yet)
              <ul>
                <li>physical processes (i.e., intended state can not be applied immediately to actual state)</li>
                <li>cloud services (e.g., client needs to be sure Thing successfully completes Action)</li>
                <li>user interfaces (e.g., progress bars)</li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h3>Events</h3>
          <p>
            The Event Interaction Pattern describes event sources that asynchronously push messages. Here not state, but
            state transitions (events) are communicated (e.g., "clicked"). Events may be triggered by internal state
            changes that are not exposed as Properties. Events usually follow strong consistency, where messages need to
            be queued to ensure eventual delivery of all occured events.
          </p>
          <ul>
            <li>
              Events opposed to observable Properties: why two mechanisms
              <ul>
                <li>Events triggered by state that is not exposed through Properties</li>
                <li>Separation of consistency requirements</li>
                <li>Duality of REST and PubSub systems</li>
              </ul>
            </li>
            <li>
              TODO: Actionable Events: Event not only has data but also Interactions
              <ul>
                <li>alerts that need to be confirmed and later marked as resolved</li>
                <li>events that contain dynamic state (Properties)</li>
              </ul>
            </li>
          </ul>
        </section>
      </section>

      <section>
        <h2>Data Model</h2>
        <p>
          Interactions exchange data using representation formats (e.g., JSON), which are identified by Media Types
          (e.g., <code>application/json</code>. Usually, applications use generic serialization formts without
          application-specific definitions (cf. JSON). Thus, TDs also needs to include metadata about the data model
          used, so-called schemas.
        </p>
        <section>
          <h3>Representation Formats</h3>
          <p>
            JSON reflects the state of the art of data interchange formats. It is not focused on how data is represented
            by a specific system (e.g., in 16 bits), but only on the fundamentals of the information.
          </p>
          <ul>
            <li>Dominant data format on the Web</li>
            <li>Implementation-independent representation of data</li>
          </ul>
          <p>
            CBOR is a concise binary representation that is related to JSON. It can express all JSON structures, but
            also has additional features such as a binary type to improve over base64-encoded blobs.
          </p>
          <ul>
            <li>Compact</li>
            <li>Low parsing complexity</li>
          </ul>
        </section>
        <section>
          <h3>Schema</h3>
          <p>
            A popular validation schema for JSON data is <a href="http://json-schema.org/">JSON Schema</a>. It defines a
            vocabulary and a syntax to specify a schema for data validation at the syntactic level.
          </p>
          <p>The Web of Things aims at semantic interoperability for Things. For this,</p>
          <p>
            Directly using the JSON Schema syntax within the TD breaks paradigms. Two different implementations would be
            needed to conduct validation. At least JSON Schema could be reused. However, semantic queries and resoning
            could not work on data structures, that is, make sense of the data in relation to the Thing and its context.
          </p>
          <ul>
            <li>Re-use of JSON Schema vocabulary</li>
            <li>Enable validation through JSON-LD</li>
          </ul>
        </section>
      </section>

      <section>
        <h2>Security Metadata</h2>
        <p>
          The TD has a top-level <code>security</code> field to carry security metadata such as the required
          authorization mechanism, authorization server, required root certificates, etc.
        </p>
        <ul>
          <li>Security</li>
          <li>Share controlled acccess to the Thing (authorization, e.g., OAuth)</li>
        </ul>
      </section>

      <section>
        <h2>Communication Metadata</h2>
        <p>
          The TD Interactions have a <code>form</code> field to carry protocol-specific metadata such as method used and
          header fields required. The concept of machine understandable forms matches the requirement of RAML, Swagger,
          OpenAPI for RESTful Web APIs.
        </p>
        <p>
          The W3C Web of Things was charted to counter the fragmentation in the IoT. Creating yet another standard does
          not help here, as existing standards with strong domain-specific knowledge have shown to hold out. Thus, W3C
          WoT was charted to describe and complement existing IoT platforms and standards. For this, a TD must be able
          to describe how a client can communicate successfully with a server.
        </p>
        <section>
          <h3>Request Metadata</h3>
          <p>
            Up to date, not even so-called RESTful Web services managed to follow a single guidline when designing their
            API. Requests always have to be tailored for each service (cf. usage of Swagger/OpenAPI).
          </p>
          <p>
            To reflect this situation in the TD, where a situation similar to RESTful APIs is expected for Things, a TD
            is able to include so called form descriptions, which go beyond Web linking: The not only describe the
            relation to a target resource and attributes of the target resource, but also descriptions how to interact
            with that resource, that is, how a client has to formulate requests (e.g., header fields or payloads).
          </p>
          <ul>
            <li>Compensate for small variations in methods</li>
            <li>Compensate for small variations in header fields</li>
          </ul>
        </section>
        <section>
          <h3>Extension Point</h3>
          <p>
            So far, there is no single IoT protocol to rule them all. The only convergence visible is a trend toward
            Internet protocols defined by the IETF and other bodies such as OASIS. Yet still every IoT platform and
            standard tends to introduce small variations, thereby creating protocol dialects.
          </p>
          <p>
            To allow for convergence of currently deployed IoT protocols and to be future proof for new protocols that
            might emerge as de facto standards, the TD has protocol bindings as explicit extension point.
          </p>
          <ul>
            <li>Use HTTP long-poll for Events</li>
            <li>Use HTTP Server-Sent Events for Events</li>
            <li>Use WebSocket sub-protocols that do not have a URI scheme</li>
            <li>Use CoAP dialects such as OCF or oneM2M</li>
            <li>Use protocols of large IoT platforms such as Amazon IoT or Azure IoT</li>
          </ul>
        </section>
        <section>
          <h3>Binding Templates</h3>
          <p>
            The <a href="https://w3c.github.io/wot-binding-templates/">WoT Binding Templates</a> document serves as
            catalog to pick the right communication metadata for well-known IoT protocols. The templates provide
            vocabulary to describe the required protocol stack configuration (e.g., specific header fields) and security
            mechanisms in the TD.
          </p>
          <p>
            Binding Templates are mainly expected for dialects of the Web protocols HTTP/1.1, HTTP/2, and CoAP,
            standardized sub-protocols for WebSockets, and widely deployed IoT protocols such as AMQP or MQTT profiles
            (e.g., Amazon IoT).
          </p>
          <ul>
            <li>Provide a common vocabulary for communication metadata</li>
          </ul>
        </section>
      </section>

      <section>
        <h2>Semantic Annotations</h2>
        <p>
          The Web of Things is centered on things. During runtime, data and metadata are primarily exchanged among
          machines for machines. Furthermore, WoT content is produced by a large number of machines. Thus, machine
          assistance is also needed for consuming the data and bulding viable business cases.
        </p>
        <section>
          <h3>Annotation Framwork</h3>
          <p>
            Semantic annotations are based on JSON-LD, which gives meaning to JSON field names and values by defining
            the terms used in the <code>@context</code> and linking them to Link Data. TDs can be annotated as follows:
          </p>
          <ul>
            <li>Thing types in the top-level <code>@type</code> array</li>
            <li>Thing capabilities</li>
            <li>Thing metadata in additional top-level fields that follow the rules of JSON-LD</li>
            <li>Interaction types in the <code>@type</code> array within Interaction elements</li>
            <li>Interaction metadata in additional sub-fields that follow the rules of JSON-LD</li>
            <li>Data types in the <code>@type</code> array within <code>schema</code></li>
          </ul>
        </section>
        <section>
          <h3>Extension Point</h3>
          <p>
            The W3C has no knowledge in the concrete application domains of Web of Things. Thus, the W3C is not
            standardizing any domain-specific vocabulary.
          </p>
          <p>
            Still, domain-specific vocabularies are of utmost importance for semantic interoperability. Thus, the TD has
            an explicit extension point that comes for free when using JSON-LD and Linked Data.
          </p>
        </section>
      </section>

      <section>
        <h2>Web Linking</h2>
        <p>The TD now has a top-level <code>link</code> field to carry links to other Web resources.</p>
        <ul>
          <li>
            In a deployment, Things usually have relations to other Things or entities such as locations, which may have
            metadata representations on their own.
          </li>
          <li>
            In the future, additional metadata might be provided as externalized Web resource, just like done for HTML
            or the Web Linking header field.
          </li>
        </ul>
      </section>
    </section>

    <section>
      <h1>Serialization Requirements</h1>
      <p></p>

      <section>
        <h2>Human-readability</h2>
        <p>
          The Web of Things is supposed to make IoT technology more usable, which includes usability for developers.
          This is fundamental to the success of Web Technology in general.
        </p>
        <p>This requirement lead to the choice of a JSON-based format for the TD.</p>
      </section>

      <section>
        <h2>Machine-understandability</h2>
        <p>
          The Web of Things is centered on things. During runtime, data and metadata are primarily exchanged among
          machines for machines. Furthermore, WoT content is produced by a large number of machines. Thus, machine
          assistance is also needed for consuming the data and bulding viable business cases.
        </p>
        <p>
          Thus, TDs must not only be machine-readible, but machine-understandable. Moreover, the TD metadata can help to
          make optimized runtime data (i.e., no metadata included in the live data exchanged) also
          machine-understandable.
        </p>

        <p>
          This requirement lead to the choice of JSON-LD, an existing W3C standard for machine-understandable JSON
          documents based on Linked Data vocabularies.
        </p>
      </section>

      <section>
        <h2>Introspection</h2>
        <p>
          Applications consuming TDs should be able to easily introspect the capabilites, possible interactions, and
          other metadata of the corresponding Things.
        </p>
        <p>
          In particular the <a href="https://w3c.github.io/wot-scripting-api/">WoT Scripting API</a> benefits from an
          alternative structure of the TD, such as separated entry points for Properties, Actions, and Events.
        </p>
      </section>

      <section>
        <h2>Default Values</h2>
        <p>
          Implementations for the PlugFest showed that basically every developer is counting on defaults, that is,
          certain elements can be omitted as their meaning is known implicitly or even irrelevant. Examples are omitting
          the <code>security</code> metadata for test Things that use no-security, omitting the
          <code>writable</code> flag for read-only Properties, or omitting <code>inputSchema</code>/<code
            >outputSchema</code
          >
          for Actions that do not take arguments and/or return nothing.
        </p>
        <p>
          Treating the JSON-LD TD strictly as Linked Data document, a collection of triples, would not allow for such
          defaults, and hence convenience. Linked Data underly the
          <a href="https://en.wikipedia.org/wiki/Open-world_assumption">open-world assumption</a>. That means, when a TD
          is omitting statements (e.g., writable flag), then the consumer cannot make any assumptions about its actual
          value.
        </p>
        <p>
          Based on the knowledge that it is a TD, the consumer could, however, apply a set rules, which infer the
          defaults. This leads to the preprocessing introduced in the next section.
        </p>
      </section>

      <section>
        <h2>Robustness Principle</h2>
        <p>
          Be conservative in what you do, be liberal in what you accept from others. Applying
          <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel's law</a>
          fosters interoperability and should also be used in the Web of Things.
        </p>
        <p>This requirement also leads to a preprocessing step that can fill in defaults and correct minor issues.</p>
      </section>
    </section>

    <section>
      <h1>Simplified TD</h1>
      <p>The Simpified TD proposal aims at solving the requirements given in the previous section.</p>

      <section>
        <h2>Preprocessing</h2>
        <p>The main change and enabler for a simplified TD is introducing a preprocessing step.</p>
        <p>
          Due to the <a href="https://en.wikipedia.org/wiki/Open-world_assumption">open-world assumption</a>, some
          preprocessing of the TD is required. The rules to fill in defaults could be applied in the following way:
        </p>
        <ul>
          <li>
            Custom rules: If semantic support through queries and reasoners is not used, simple hard-coded rules can
            fill in the defaults when the internal model of the implementation is created. A drawback is that this
            hinders common, re-usable tooling.
          </li>
          <li>
            Rule languages: Most knowledge bases have support for rule languages, which could create the missing triples
            for the defaults. A drawback is that there is no one standard that would be available in all knowledge
            bases.
          </li>
          <li>
            Query rewriting: Instead of having the default triples materialized in the knowledge base, the queries
            retrieving the knowledge could be patched so that they return the results as if the default values were
            present.
          </li>
          <li>
            Normalize the TD: The TD specification can define a set of rules that have to be applied to all incoming TD
            documents in a preprocessing step.
          </li>
        </ul>
        <p>Normalizing the TD in a preprocessing step also helps for robustness. Thus, this is a favorable solution.</p>
        <p>
          <a href="https://json-ld.org/spec/latest/json-ld-framing/">JSON-LD&nbsp;1.1 Frameing</a> can be used to define
          and apply the preprocessing steps.
        </p>
        <p>
          <b>NOTE:</b> Even with JSON-LD 1.1 available, there are still open issues. For instance, the object key
          becomes the <code>@id</code> of the Property node defined in the object value: To derive sensible triples, the
          object key would need to be declared either as "blank node" by prefixing with <code>_:</code>, or the
          container mechanism must be able generate relative <code>@id</code>s to avoid conflicts when an object key
          appears twice at different levels.
        </p>
      </section>

      <section>
        <h2>Media Type</h2>
        <p>
          When TDs are not a valid JSON-LD document due to necessary preprocessing or simply an omitted
          <code>@context</code>, they need their own media type registered with IANA.
        </p>
        <p>We propose <code>application/td+json</code>.</p>
      </section>

      <section>
        <h2>New Terms</h2>
        <section>
          <h3><code>link</code></h3>
          <p>
            The Working Draft for the Prague 2018 PlugFest already adopted a top-level <code>link</code> field, so that
            a TD can express relations to other Things or other Web resources.
          </p>
          <p>
            Note that because the TD is JSON-LD, such relations were always possible and are actually always expressed
            for all top-level fields (it is Linked Data). Having the term <code>link</code> makes it explicit that the
            elements included there are actual Web Links to fetchable Web resources, opposed to Linked Data URIs
            ("IRIs") that are often only an identifier without an actual Web resource.
          </p>
        </section>
        <section>
          <h3><code>description</code></h3>
          <p>
            The term <code>description</code> is very useful and shall become part of the TD core vocabulary for both
            Thing and Interactions.
          </p>
        </section>
        <section>
          <h3><code>name</code></h3>
          <p>
            The term <code>name</code> would not be the identifier for Interactions anymore. Following JSON-LD 1.1, the
            object key would become <code>@id</code>, which would serve as handle to select Interactions, e.g., for the
            Scripting API.
          </p>
          <p>
            With that, <code>name</code> becomes either obsolete or rather could be used as optional, human-readible
            label. As a result, for Things, <code>name</code> becomes a mandatory label. For Interactions, the new,
            optional term <code>label</code> is used.
          </p>
        </section>
        <section>
          <h3><code>id</code></h3>
          <p>
            On the top level, <code>id</code> will become important for security and identity management. It identifies
            the instance of Thing and also serves as the <code>@base</code> for all other <code>@id</code> definitions
            (e.g., of Interactions). Only this fully enables the object notation of Interactions (opposed to the
            previous array notation). The top-level <code>id</code> must be mandatory and internally maps to the
            <code>@id</code> of the Thing. Therefore, a Thing <code>id</code> must be a URI (which includes URNs).
          </p>
          <p>
            For Interactions, <code>@id</code> would be the handle for scripts and it would enable references to and
            between Interactions, e.g., for cross-Property constraints or for expressing relations between an action and
            one or more Properties. Note that this would result automatically from the object structure listing
            Interactions because of JSON-LD 1.1 (<a
              href="https://json-ld.org/spec/latest/json-ld/#node-identifier-indexing"
              >Node Identifier Indexing</a
            >).
          </p>
        </section>
      </section>

      <section>
        <h2>Model Changes</h2>

        <p>
          To enable alignment with other technologies such as JSON Schema, the Simplified TD needs a few small changes
          to the TD core model. It has to be evaluated if these changes are actually breaking changes (i.e., a JSON-LD
          1.0 TD would create different triples than a Simplified TD).
        </p>

        <section>
          <h3>Properties</h3>
          <p>
            Using the term <code>properties</code> also for the object field names of complex Properties (i.e.,
            <code>"type": "object"</code>) aligns the TD with JSON Schema syntax. This results in recursive Properties,
            where
          </p>
          <ul>
            <li>Properties also have the <code>DataSchema</code> RDF-type</li>
            <li>Only properties that have a <code>forms</code> field are Interaction Properties.</li>
            <li>
              Sub-properties of complex Properties might be directly addressable and accessible, when they have the
              <code>forms</code> field.
            </li>
          </ul>
        </section>
      </section>

      <section>
        <h2>Simplified TD by Example</h2>

        <p>
          When no <code>@context</code> is given, the
          <a href="https://w3c.github.io/wot-thing-description/proposals/simplified-td/w3c-wot-td-context.jsonld"
            >Simplified TD context</a
          >
          is assumed based on the media type (file location needs update for adoption). The current TD context also
          needs an additional definition of <code>@base</code> set to the Thing's <code>@id</code>, so that the object
          representation of Interactions produces correct <code>@id</code>s for the Interactions.
        </p>

        <pre class="example" title="Default context applied to application/td+json">
{
  "@context": {
    /* enable JSON-LD 1.1 processing */
    "@version": 1.1,
    /* valid @id generation relative to Thing instance */
    "@base": "@id",
    /* object notation for Interactions */
    "properties": {
      "@container": "@id"
    },
    "actions": {
      "@container": "@id"
    },
    "events": {
      "@container": "@id"
    },
    /* optional if schema definitions are wanted */
    "definitions": {
      "@container": "@id"
    },
    /* TD term definitions as in https://w3c.github.io/wot/w3c-wot-td-context.jsonld */
    ...
  }
}
        </pre>

        <p>
          When <code>@context</code> is given, the
          <a href="https://w3c.github.io/wot-thing-description/proposals/simplified-td/w3c-wot-td-context.jsonld"
            >Simplified TD context</a
          >
          is applied last to ensure that the terms of the TD core vocabulary are valid and not shadowed by other
          contexts.
        </p>

        <section>
          <h3>Minimal Simplified TD</h3>

          <p>
            The first example reflects the minimal option. It contains no semantic annotations, nor human-readible
            decorators such as <code>name</code> or <code>description</code>.
          </p>

          <pre class="example" title="Minimal Simplified TD">
{
  "name": "Lamp",
  "id": "urn:dev:wot:com:example:servient:lamp",
  "base": "https://servient.example.com/",
  "properties": {
    "on": {
      "type": "boolean",
      "forms": [{
        "href": "/things/lamp/properties/on",
        "mediaType": "application/json"
      }]
    },
    "status": {
      "readOnly": true,
      "type": "object",
      "properties": {
        "battery": {
          "type": "number",
          "minimum": 0.0,
          "maximum": 100.0,
          "forms": [{
            "href": "/things/lamp/properties/status/batt",
            "mediaType": "application/json"
          }]
        },
        "rssi": {
          "type": "number",
          "minimum": 0.0,
          "maximum": 1.0
        },
        "level": {
          "type": "integer",
          "minimum": 0,
          "maximum": 100
        }
      },
      "forms": [{
        "href": "/things/lamp/properties/status",
        "mediaType": "application/json"
      }]
    },
    "brightness": {
      "type": "integer",
      "minimum": 0,
      "maximum": 100
      "forms": [{
        "href": "/things/lamp/properties/brightness",
        "mediaType": "application/json"
      }]
    }
  },
  "actions": {
    "fade": {
      "input": {
        "type": "object",
        "properties": {
          "from": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          },
          "to": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          },
          "duration": { "type": "number" }
        }
      },
      "forms": [{
        "href": "/things/lamp/actions/fade",
        /* encType would be for the request body opposed to mediaType, which is for target */
        "encType": "application/json",
        "mediaType": "application/json"
      }]
    }
  },
  "events": {
    "overheated": {
      "type": "object",
      "properties": {
        "temperature": { "type": "number" }
      },
      "forms": [{
        "href": "/things/lamp/events/overheated",
        "http:subProtocol": "http:EventSource",
        "mediaType": "application/json"
      }]
    }
  },
  "links": [{
    "href": "https://servient.example.com/things/motion-detector",
    "rel": "controlledBy",
    "mediaType": "application/td+json"
  }]
}
          </pre>
        </section>

        <section>
          <h3>Annotated Simplified TD (with semantics)</h3>

          <pre class="example" title="Annotated Simplified TD">
{
  "@context": { "iot": "https://iot.schema.org/" },
  "name": "Lamp",
  "description": "Corner torchiere",
  "@type": ["Thing", "iot:Light"],
  "id": "urn:dev:wot:com:example:servient:lamp",
  "base": "https://servient.example.com/",
  "properties": {
    "on": {
      "label": "On/Off",
      "description": "Power switch",
      "@type": "iot:SwitchStatus",
      "type": "boolean",
      "forms": [{
        "href": "/things/lamp/properties/on",
        "mediaType": "application/json"
      }]
    },
    "status": {
      "readOnly": true,
      "@type": "iot:DeviceStatus",
      "type": "object",
      "properties": {
        "battery": {
          "@type": "iot:BatteryLevel",
          "type": "number",
          "minimum": 0.0,
          "maximum": 100.0,
          "forms": [{
            "href": "/things/lamp/properties/status/batt",
            "mediaType": "application/json"
          }]
        },
        "rssi": {
          "@type": "iot:SignalStrength",
          "type": "number",
          "minimum": 0.0,
          "maximum": 1.0
        },
        "level": {
          "@type": "iot:CurrentLevel",
          "type": "integer",
          "minimum": 0,
          "maximum": 100
	}
      },
      "forms": [{
        "href": "/things/lamp/properties/status",
        "mediaType": "application/json"
      }]
    },
    "brightness": {
      "@type": "iot:CurrentLevel",
      "type": "integer",
      "minimum": 0,
      "maximum": 100,
      "forms": [{
        "href": "/things/lamp/properties/status",
        "mediaType": "application/json"
      }]
    }
  },
  "actions": {
    "fade": {
      "input": {
        "type": "object",
        "properties": {
          "from": {
            "@type": "iot:CurrentLevel",
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          },
          "to": {
            "@type": "iot:TargetLevel",
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          },
          "duration": {
	    "@type": "iot:TransitionTimeData",
	    "type": "number"
	  }
        }
      },
      "forms": [{
        "href": "/things/lamp/actions/fade",
        /* encType would be for the request body
           opposed to mediaType, which is for target */
        "encType": "application/json",
        "mediaType": "application/json",
        /* redundant to default here, just to indicate
           imagine a PATCH Action or a CoAP FETCH Action */
        "http:methodName": "POST"
      }]
    }
  },
  "events": {
    "overheated": {
      "type": "object",
      "properties": {
        "temperature": { "type": "number" }
      },
      "forms": [{
        "href": "/things/lamp/events/overheated",
        "http:subProtocol": "http:EventSource",
        "mediaType": "application/json"
      }]
    }
  },
  "links": [{
    "href": "https://servient.example.com/things/motion-detector",
    "rel": "controlledBy",
    "mediaType": "application/td+json"
  }]
}
          </pre>
        </section>
      </section>
    </section>

    <section>
      <h1>JSON-LD 1.0 TD</h1>

      <p>This section summerizes the status of the JSON-LD 1.0-based Thing Description (until Prague 2018 WD).</p>

      <section>
        <h2>JSON-LD 1.0 TD by Example</h2>

        <section>
          <h3>Minimal JSON-LD</h3>

          <p>
            This example reflects the minimal option. It contains no semantic annotations, nor human-readible decorators
            such as <code>name</code> or <code>description</code>.
          </p>

          <pre class="example" title="Minimal JSON-LD 1.0 TD">
  {
    "@context": "https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
    "name": "Lamp",
    "@id": "urn:dev:wot:com:example:servient:lamp",
    "base": "https://servient.example.com/",
    "interaction": [{
      "@type": "Property",
      "name": "on",
      "writable": true,
      "schema": { "type": "boolean" },
      "form": [{ "href": "/things/lamp/properties/on" }]
    }, {
      "@type": "Property",
      "name": "status",
      "writable": false,
      "schema": {
        "type": "object",
	"field": [{
	  "name": "battery",
	  "type": "number",
          "minimum": 0.0,
          "maximum": 100.0
	}, {
	  "name": "rssi",
	  "type": "number",
          "minimum": 0.0,
          "maximum": 1.0
	}, {
	  "name": "level",
	  "type": "integer",
          "minimum": 0,
          "maximum": 100
	}]
      },
      "form": [{ "href": "/things/lamp/properties/on" }]
    }, {
      "@type": "Property",
      "name": "brightness",
      "writable": true,
      "schema": {
        "type": "number",
        "minimum": 0,
        "maximum": 100
      },
      "form": [{ "href": "/things/lamp/properties/brightness" }]
    }, {
      "@type": "Action",
      "name": "fade",
      "inputSchema": {
        "type": "object",
        "field": [{
          "name": "from",
          "schema": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          }
        }, {
          "name": "to",
          "schema": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          }
        }, {
          "name": "duration",
          "schema": { "type": "number" }
        }]
      },
      "form": [{ "href": "/things/lamp/actions/fade" }]
    }, {
      "@type": "Event",
      "name": "overheated",
      "schema": {
        "type": "object",
        "field": [{
          "name": "temperature",
          "schema": { "type": "number" }
        }]
      },
      "form": [{ "href": "/things/lamp/events/overheated" }]
    }],
    "link": [{
      "href": "https://servient.example.com/things/motion-detector",
      "rel": "controlledBy",
      "mediaType": "application/ld+json"
    }]
  }
            </pre
          >
        </section>
        <section>
          <h3>Annotated JSON-LD 1.0 TD</h3>
          <!--
            <pre class="example" title="JSON-LD 1.0 TD with semantic annotations">
  {
    "@context": [
      "https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
      { "iot": "http://iotschema.org/" },
      { "http": "http://iotschema.org/protocol/http#" }
    ],
    "definitions": { /* optional if wanted! for free by JSON-LD */
      "range": {
        "@type": ["iot:LevelData"],
        "type": "integer",
        "minimum": 0,
        "maximum": 100
      }
    },
    "@type": ["Thing", "iot:Light", "iot:BinarySwitch", "iot:LevelCapability"],
    "name": "lamp",
    "description": "A Web-connected lamp",
    "@id": "urn:dev:wot:com:example:servient:lamp",
    "base": "https://servient.example.com/",
    "properties": {
      "on": {
        "name": "On/Off",
        "description": "Whether the lamp is turned on",
        "@type": ["iot:SwitchStatus"],
        "writable": true,
        "observable": true,
        "schema": {
          "@type": ["iot:SwitchData"],
          "type": "boolean"
        },
        "forms": [{
          "href": "/things/lamp/properties/on",
          "rel": ["get", "set"]
        }, {
          "href": "/things/lamp/properties-push/on",
          "rel": ["observe"],
          "http:SubProtocol": "http:ServerSentEvents"
        }]
      },
      "brightness": {
        "name": "Brightness",
        "description": "The level of light from 0-100",
        "@type": ["iot:CurrentLevel"],
        "writable": true,
        "observable": true,
        "schema": "range",
        "forms": [{
          "href": "/things/lamp/properties/brightness",
          "rel": ["get", "set"]
        }, {
          "href": "/things/lamp/properties-push/brightness",
          "rel": ["observe"],
          "http:SubProtocol": "http:ServerSentEvents"
        }]
      }
    },
    "actions": {
      "fade": {
        "name": "Fade",
        "description": "Fade from one level to another",
        "@type": ["iot:SetLevel"],
        "inputSchema": {
          "type": "object",
          "fields": [{
            "name": "from",
            "schema": "range",
          }, {
            "name": "to",
            "schema": "range",
          }, {
            "name": "duration",
            "@type": ["iot:TransitionTimeData"],
            "schema": { "type": "number" }
          }]
        },
        "forms": [{ "href": "/things/lamp/actions/fade" }]
      }
    },
    "events": {
      "overheated": {
        "schema": {
          "type": "object",
          "fields": [{
            "name": "temperature",
            "schema": { "type": "number" }
          }]
        },
        "forms": [{
          "href": "/things/lamp/events/overheated",
          "http:subProtocol": "http:EventSource"
        }]
      }
    },
    "links": [{
      "href": "https://servient.example.com/things/motion-detector",
      "rel": "controlledBy",
      "mediaType": "application/td"
    }]
  }
            </pre>
-->
        </section>
      </section>
    </section>

    <section>
      <h1>JSON Web Thing Description (JSON-TD)</h1>
      <p>
        The following JSON example was build from snippets taken from
        <a href="https://w3c.github.io/wot/proposals/json-td/index.html">here</a>.
      </p>

      <section>
        <h2>JSON-TD by Example</h2>

        <pre class="example" title="JSON-TD Example">
{
  "name": "My Lamp",
  "type": "thing",
  "description": "A web connected lamp",
  "properties": {
    "on": {
      "type": "boolean",
      "description": "Whether the lamp is turned on",
      "href": "/things/lamp/properties/on"
    },
    "brightness": {
      "type": "number",
      "description": "The level of light from 0-100",
      "minimum": 0,
      "maximum": 100,
      "href": "/things/lamp/properties/brightness"
    }
  },
  "actions": {
    "fade": {
      "name": "Fade",
      "description": "Fade from one brightness to another",
      "data": {
        "from": {
          "type": "number",
          "minimum": 0,
          "maximum": 100
        },
        "to": {
          "type": "number",
          "minimum": 0,
          "maximum": 100
        },
        "duration": {
          "type": "number",
          "unit": "milliseconds"
        }
      },
      "href": "/things/lamp/actions/fade"
    }
  },
  "events": {
    "overheated": {
      "name": "Overheated",
      "description": "The device exceeded its maximum safe operating temperature",
      "data": {
        "temperature": {
          "type": "number",
          "unit": "celcius"
        }
      }
    }
  },
  "links": {
    "properties": "/thing/lamp/properties",
    "actions": "/things/lamp/actions",
    "events": "/things/lamp/events"
  }
}
        </pre>
      </section>
    </section>

    <section>
      <h1>Comparing "Progressive Simplified TD" to "JSON-TD"</h1>
      <ul>
        <li>Has markup for writable and observable</li>
        <li>
          Data schema of Properties is put into a <code>schema</code> sub-field
          <ul>
            <li>Allows referencing defined types</li>
            <li>Helps to cluster potentially complex schema definitions</li>
            <li>Similar to Actions and Events</li>
          </ul>
        </li>
        <li>
          Data schema of Actions is put into a <code>schema</code> sub-field, not <code>data</code>
          <ul>
            <li>Similar to Properties and Events</li>
          </ul>
        </li>
        <li>
          Action parameters are put into a single schema
          <ul>
            <li>Explicitly models marshalling of multiple parameters</li>
            <li>Matches body/payload based paradigm of Web protocols</li>
          </ul>
        </li>
        <li>
          Data schema of Events is put into a <code>schema</code> sub-field, not <code>data</code>
          <ul>
            <li>Similar to Properties and Actions</li>
          </ul>
        </li>
        <li>
          URI etc. is put into a <code>forms</code> sub-field
          <ul>
            <li>Allows for alternate URIs</li>
            <li>Serves as clean extension point for protocol bindings</li>
          </ul>
        </li>
        <li>Links are used to link to external related Web resources</li>
        <li>(Data schema is fully defined)</li>
        <li>(Option for semantic annotations)</li>
      </ul>
    </section>
  </body>
</html>
