<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Simplified WoT Thing Description</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
    <script class="remove">
      var respecConfig = {
        specStatus: "ED"
      , processVersion: 2017
      , shortName: "wot-thing-description-simplified"
      , wg: "Web of Things Working Group"
      , wgURI: "https://www.w3.org/WoT/WG/"
      , edDraftURI : "https://w3c.github.io/wot-thing-description/proposals/simplified-json-ld/index.html"
      , editors: [{
          name: "Matthias Kovatsch",
          company: "Siemens AG"
        },{
          name: "Sebastian Kaebisch",
          company: "Siemens AG"
        },{
          name: "Victor Charpenay",
          company: "Siemens AG"
        }]
      , charterDisclosureURI: 'https://www.w3.org/2016/07/wot-wg-charter.html#patentpolicy'
      , otherLinks: [{
          key: "Repository",
          data: [
            {
              value: "We are on GitHub"
            , href: "https://github.com/w3c/wot-thing-description/tree/master/proposals/simplified-td"
            }
          , {
              value: "File a bug"
            , href: "https://github.com/w3c/wot-thing-description/issues"
            }
          ]
        }]
      };
    </script>
    <style>
      table{
          width: 100%;
          border: solid 1px #005A9C;
          border-collapse: collapse;
      }
      th{
          background-color: #005A9C;
          color: white;
      }
      td,
      th{
          border: solid 1px #005A9C;
          padding: 4px;
      }</style>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document summarizes the discussions on simplifying the JSON-LD&nbsp;1.0-based <a href="https://www.w3.org/TR/2018/WD-wot-thing-description-20180405/">WoT Thing Description</a> and proposes a simplified TD serialization based on <a href="https://json-ld.org/spec/latest/json-ld/">JSON-LD&nbsp;1.1</a>.
        The proposal lists the features of the TD core model and gives use cases per feature.
        The proposed "Simplified TD" serialization is given in the form of extensive examples.
        Specification text will be added when merging this proposal into the WoT Thing Description <a href="https://w3c.github.io/wot-thing-description/">Editors' Draft</a>.
        For convenience, examples of the JSON-LD&nbsp;1.0 serialization and the alternative <a href="https://w3c.github.io/wot/proposals/json-td/index.html">JSON Web Thing Description</a> (a.k.a. JSON-TD) are given for comparison.
        This document concludes with a list of differences in the proposals.
      </p>
    </section>

    <section id="sotd">
      <p> </p>
    </section>

    <section>
      <h1>Introduction</h1>
      <p>
        The <a href="https://www.w3.org/TR/2018/WD-wot-thing-description-20180405/">WoT Thing Description</a> based on JSON-LD&nbsp;1.0 has been criticized for several limitations including complexity and the JSON-LD&nbsp;1.0 array structures and keywords even when no semantic annotations are used.
        This lead to an alternative draft, the <a href="https://w3c.github.io/wot/proposals/json-td/index.html">JSON Web Thing Description</a>, with a pure JSON serialization, which however, would fragment W3C WoT due to incompatible models behind the serializations.
        To remedy the situation, this document proposes a simplified TD serialization based on <a href="https://json-ld.org/spec/latest/json-ld/">JSON-LD&nbsp;1.1</a>,
        thereby combining both requirements:
        machine-understandability through a formal Linked Data model from the original WoT Thing Description and improved usability from the JSON Web Thing Description.
        Being able to conduct these simplifications first required a full understanding of the requirements, which have been analyzed by the Working Group since its chartering.
        This technical deep-dive completed around TPAC 2017 (Burlingame), where the Working Group announced to change the goal toward simplification from there onward.
      </p>
    </section>

    <section>
      <h1>Use Cases per TD Feature</h1>
      <p>
        Many discussions are rooted on the question whether a certain feature should be included or not.
        This section lists the features currently included in the <a href="https://www.w3.org/TR/2018/WD-wot-thing-description-20180405/#overview">TD core model</a> and backs them by use cases.
      </p>

      <section>
        <h2>Interaction Model</h2>
        <p>
          To represent a contract between applications with programming APIs and IoT devices with network APIs,
          the communication with Things must be modeled with a formal interaction model.
          This describes not only <emph>what</emph> data a Thing provides or requires,
          but also <emph>how</emph> to access and manipulate the corresponding internal state of a Thing.
        </p>
        <p>
          Based on the <a href="https://www.w3.org/Submission/wot-model/">Web Thing Model</a>
          and results of the <a href="http://www.compose-project.eu/">COMPOSE project</a>
          the WoT Interest Group explored a threefold of Interactions, which was
          adopted by the WoT Working Group after 2 years of stability:
        </p>
        <section>
          <h3>Properties</h3>
          <p>
            Properties expose internal state of a Thing that can be directly accessed (get) and optionally manipulated (set).
            Things can also choose to make Properties observable by pushing the new state (not an event) after a change;
            this must follow eventual consistency (also see <a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP Theorem</a>).
          </p>
          <ul>
            <li>Read-only Properties: state cannot be changed from the outside
              <ul>
                <li>sensors</li>
                <li>results computed from internal state</li>
              </ul>
            </li>
            <li>Writable Properties: state needs to be changed directly from the outside
              <ul>
                <li>configuration state</li>
                <li>setpoints</li>
                <li>more concise model when intended state can be applied to actual state immediately (no Action needed)</li>
              </ul>
            </li>
            <li>Observable Properties: optimize communication through server push
              <ul>
                <li>keep state in sync with relaxed consistency (eventual consistency)</li>
                <li>directly maps to CoAP Observe</li>
              </ul>
            </li>
            <li>TODO: Recursive Properties: address sub-properties of a complex Property (to be done for Simplified TD)
              <ul>
                <li>nested Properties that are also exposed by the Thing (e.g., LWM2M Devices/IPSO Objects)</li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h3>Actions</h3>
          <p>
            Actions offer functions of the Thing.
            These functions may manipulate the interal state of a Thing in a way that is not possible through setting Properties.
            Examples are changing internal state that is not exposed as Property, changing multiple Properties, changing Properties over time or with a process that shall not be disclosed.
            Actions may also be pure functions, that is, they do not use any internal state at all, e.g., for processing input data and returning the result directly.
          </p>
          <ul>
            <li>Action arguments: the function needs input parameters
              <ul>
                <li>write-multiple commands</li>
                <li>functions with parameters</li>
              </ul>
            </li>
            <li>Action results: the function returns a result
              <ul>
                <li>read-multiple commands (e.g., CoAP FETCH)</li>
                <li>sensors that are not based on sampling / fit for Properties (e.g., power-intensive sensors)</li>
                <li>function reports (e.g., calibration Action)</li>
                <li>processing functions (e.g., data conversion)</li>
              </ul>
            </li>
            <li>TODO: Monitorable Actions: process can be monitored, changed, canceled once invoked (not in TD core model yet)
              <ul>
                <li>physical processes (i.e., intended state can not be applied immediately to actual state)</li>
                <li>cloud services (e.g., client needs to be sure Thing successfully completes Action)</li>
                <li>user interfaces (e.g., progress bars)</li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h3>Events</h3>
          <p>
            The Event Interaction Pattern describes event sources that asynchronously push messages.
            Here not state, but state transitions (events) are communicated (e.g., "clicked").
            Events may be triggered by internal state changes that are not exposed as Properties.
            Events usually follow strong consistency, where messages need to be queued to ensure eventual delivery of all occured events.
          </p>
          <ul>
            <li>Events opposed to observable Properties: why two mechanisms
              <ul>
                <li>Events triggered by state that is not exposed through Properties</li>
                <li>Separation of consistency requirements</li>
                <li>Duality of REST and PubSub systems</li>
              </ul>
            </li>
            <li>TODO: Actionable Events: Event not only has data but also Interactions
              <ul>
                <li>alerts that need to be confirmed and later marked as resolved</li>
                <li>events that contain dynamic state (Properties)</li>
              </ul>
            </li>
          </ul>
        </section>
      </section>

      <section>
        <h2>Data Model</h2>
        <p>
          Interactions exchange data using representation formats (e.g., JSON),
          which are identified by Media Types (e.g., <code>application/json</code>.
          Usually, applications use generic serialization formts without
          application-specific definitions (cf. JSON). Thus, TDs also needs to
          include metadata about the data model used, so-called schemas.
        </p>
        <section>
          <h3>Representation Formats</h3>
          <p>
            JSON reflects the state of the art of data interchange formats.
            It is not focused on how data is represented by a specific system
            (e.g., in 16 bits), but only on the fundamentals of the information.
          </p>
          <ul>
            <li>Dominant data format on the Web</li>
            <li>Implementation-independent representation of data</li>
          </ul>
          <p>
            CBOR is a concise binary representation that is related to JSON.
            It can express all JSON structures, but also has additional
            features such as a binary type to improve over base64-encoded blobs.
          </p>
          <ul>
            <li>Compact</li>
            <li>Low parsing complexity</li>
          </ul>
        </section>
        <section>
          <h3>Schema</h3>
          <p>
            A popular validation schema for JSON data is <a href="http://json-schema.org/">JSON Schema</a>.
            It defines a vocabulary and a syntax to specify a schema for data validation
            at the syntactic level.
          </p>
          <p>
            The Web of Things aims at semantic interoperability for Things. For this,
            
          </p>
          <p>
            Directly using the JSON Schema syntax within the TD breaks paradigms.
            Two different implementations would be needed to conduct validation.
            At least JSON Schema could be reused.
            However, semantic queries and resoning could not work on data structures,
            that is, make sense of the data in relation to the Thing and its
            context.
          </p>
          <ul>
            <li>Re-use of JSON Schema vocabulary</li>
            <li>Enable validation through JSON-LD</li>
          </ul>
        </section>
      </section>

      <section>
        <h2>Security Metadata</h2>
        <p>
          The TD has a top-level <code>security</code> field to carry security
          metadata such as the required authorization mechanism, authorization
          server, required root certificates, etc.
        </p>
          <ul>
            <li>Security</li>
            <li>Share controlled acccess to the Thing (authorization, e.g., OAuth)</li>
          </ul>
      </section>

      <section>
        <h2>Communication Metadata</h2>
        <p>
          The TD Interactions have a <code>form</code> field to carry protocol-specific metadata such as method used and header fields required.
          The concept of machine understandable forms matches the requirement of RAML, Swagger, OpenAPI for RESTful Web APIs.
        </p>
        <p>
          The W3C Web of Things was charted to counter the fragmentation in the IoT.
          Creating yet another standard does not help here, as existing standards with strong domain-specific knowledge have shown to hold out.
          Thus, W3C WoT was charted to describe and complement existing IoT platforms and standards.
          For this, a TD must be able to describe how a client can communicate successfully with a server.
        </p>
        <section>
          <h3>Request Metadata</h3>
          <p>
            Up to date, not even so-called RESTful Web services managed to follow a single guidline when designing their API.
            Requests always have to be tailored for each service (cf. usage of Swagger/OpenAPI).
          </p>
          <p>
            To reflect this situation in the TD, where a situation similar to RESTful APIs is expected for Things,
            a TD is able to include so called form descriptions, which go beyond Web linking:
            The not only describe the relation to a target resource and attributes of the target resource,
            but also descriptions how to interact with that resource, that is,
            how a client has to formulate requests (e.g., header fields or payloads).
          </p>
          <ul>
            <li>Compensate for small variations in methods</li>
            <li>Compensate for small variations in header fields</li>
          </ul>
        </section>
        <section>
          <h3>Extension Point</h3>
          <p>
            So far, there is no single IoT protocol to rule them all.
            The only convergence visible is a trend toward Internet protocols defined by the IETF and other bodies such as OASIS.
            Yet still every IoT platform and standard tends to introduce small variations, thereby creating protocol dialects.
          </p>
          <p>
            To allow for convergence of currently deployed IoT protocols and to be future proof for new protocols that might emerge as de facto standards,
            the TD has protocol bindings as explicit extension point.
          </p>
          <ul>
            <li>Use HTTP long-poll for Events</li>
            <li>Use HTTP Server-Sent Events for Events</li>
            <li>Use WebSocket sub-protocols that do not have a URI scheme</li>
            <li>Use CoAP dialects such as OCF or oneM2M</li>
            <li>Use protocols of large IoT platforms such as Amazon IoT or Azure IoT</li>
          </ul>
        </section>
        <section>
          <h3>Binding Templates</h3>
          <p>
            The <a href="https://w3c.github.io/wot-binding-templates/">WoT Binding Templates</a> document serves as catalog
            to pick the right communication metadata for well-known IoT protocols.
            The templates provide vocabulary to describe the required protocol stack configuration (e.g., specific header fields) and security mechanisms in the TD.
          </p>
          <p>
            Binding Templates are mainly expected for dialects of the Web protocols HTTP/1.1, HTTP/2, and CoAP,
            standardized sub-protocols for WebSockets,
            and widely deployed IoT protocols such as AMQP or MQTT profiles (e.g., Amazon IoT).
          </p>
          <ul>
            <li>Provide a common vocabulary for communication metadata</li>
          </ul>
        </section>
      </section>

      <section>
        <h2>Semantic Annotations</h2>
        <p>
          The Web of Things is centered on things. During runtime, data and metadata are primarily exchanged among machines for machines.
          Furthermore, WoT content is produced by a large number of machines.
          Thus, machine assistance is also needed for consuming the data and bulding viable business cases.
        </p>
        <section>
          <h3>Annotation Framwork</h3>
          <p>
            Semantic annotations are based on JSON-LD, which gives meaning to JSON field names and values
            by defining the terms used in the <code>@context</code> and linking them to Link Data.
            TDs can be annotated as follows:
          </p>
          <ul>
            <li>Thing types in the top-level <code>@type</code> array</li>
            <li>Thing capabilities</li>
            <li>Thing metadata in additional top-level fields that follow the rules of JSON-LD</li>
            <li>Interaction types in the <code>@type</code> array within Interaction elements</li>
            <li>Interaction metadata in additional sub-fields that follow the rules of JSON-LD</li>
            <li>Data types in the <code>@type</code> array within <code>schema</code></li>
          </ul>
        </section>
        <section>
          <h3>Extension Point</h3>
          <p>
            The W3C has no knowledge in the concrete application domains of Web of Things.
            Thus, the W3C is not standardizing any domain-specific vocabulary.
          </p>
          <p>
            Still, domain-specific vocabularies are of utmost importance for semantic interoperability.
            Thus, the TD has an explicit extension point that comes for free when using JSON-LD and Linked Data.
          </p>
        </section>
      </section>

      <section>
        <h2>Web Linking</h2>
        <p>
          The TD now has a top-level <code>link</code> field to carry links to other Web resources.
        </p>
        <ul>
          <li>
            In a deployment, Things usually have relations to other Things or entities such as locations, which may have metadata representations on their own.
          </li>
          <li>
            In the future, additional metadata might be provided as externalized Web resource, just like done for HTML or the Web Linking header field.
          </li>
        </ul>
      </section>

    </section>

    <section>
      <h1>Serialization Requirements</h1>
      <p>
      </p>

      <section>
        <h2>Human-readability</h2>
        <p>
          The Web of Things is supposed to make IoT technology more usable, which includes usability for developers.
          This is fundamental to the success of Web Technology in general.
        </p>
        <p>
          This requirement lead to the choice of a JSON-based format for the TD.
        </p>
      </section>

      <section>
        <h2>Machine-understandability</h2>
        <p>
          The Web of Things is centered on things. During runtime, data and metadata are primarily exchanged among machines for machines.
          Furthermore, WoT content is produced by a large number of machines.
          Thus, machine assistance is also needed for consuming the data and bulding viable business cases.
        </p>
        <p>
          Thus, TDs must not only be machine-readible, but machine-understandable.
          Moreover, the TD metadata can help to make optimized runtime data
          (i.e., no metadata included in the live data exchanged)
          also machine-understandable.
        <p>
          This requirement lead to the choice of JSON-LD, an existing W3C standard
          for machine-understandable JSON documents based on Linked Data vocabularies.
        </p>
      </section>

      <section>
        <h2>Introspection</h2>
        <p>
          Applications consuming TDs should be able to easily introspect the
          capabilites, possible interactions, and other metadata of the corresponding Things.
        </p>
        <p>
          In particular the <a href="https://w3c.github.io/wot-scripting-api/">WoT Scripting API</a> benefits from
          an alternative structure of the TD, such as separated entry points for Properties, Actions, and Events.
        </p>
      </section>

      <section>
        <h2>Default Values</h2>
        <p>
          Implementations for the PlugFest showed that basically every developer is counting on defaults,
          that is, certain elements can be omitted as their meaning is known implicitly or even irrelevant.
          Examples are omitting the <code>security</code> metadata for test Things that use no-security,
          omitting the <code>writable</code> flag for read-only Properties,
          or omitting <code>inputSchema</code>/<code>outputSchema</code> for Actions that do not take arguments and/or return nothing.
        </p>
        <p>
          Treating the JSON-LD TD strictly as Linked Data document, a collection of triples, would not allow for such defaults, and hence convenience.
          Linked Data underly the <a href="https://en.wikipedia.org/wiki/Open-world_assumption">open-world assumption</a>.
          That means, when a TD is omitting statements (e.g., writable flag), then the consumer cannot make any assumptions about its actual value.
        </p>
        <p>
          Based on the knowledge that it is a TD, the consumer could, however, apply a set rules, which infer the defaults.
          This leads to the preprocessing introduced in the next section.
        </p>
      </section>

      <section>
        <h2>Robustness Principle</h2>
        <p>
          Be conservative in what you do, be liberal in what you accept from others.
          Applying <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel's law</a>
          fosters interoperability and should also be used in the Web of Things.
        </p>
        <p>
          This requirement also leads to a preprocessing step that can fill in
          defaults and correct minor issues.
        </p>
      </section>
    </section>

    <section>
      <h1>Simplified TD</h1>
      <p>
        The Simpified TD proposal aims at solving the requirements given in the previous section.
      </p>

      <section>
        <h2>Preprocessing</h2>
        <p>
          The main change and enabler for a simplified TD is introducing a
          preprocessing step.
        </p>
        <p>
          Due to the <a href="https://en.wikipedia.org/wiki/Open-world_assumption">open-world assumption</a>,
          some preprocessing of the TD is required.
          The rules to fill in defaults could be applied in the following way:
          <ul>
            <li>Custom rules: If semantic support through queries and reasoners
              is not used, simple hard-coded rules can fill in the defaults when
              the internal model of the implementation is created. A drawback is
              that this hinders common, re-usable tooling.</li>
            <li>Rule languages: Most knowledge bases have support for rule
              languages, which could create the missing triples for the defaults.
              A drawback is that there is no one standard that would be available
              in all knowledge bases.</li>
            <li>Query rewriting: Instead of having the default triples materialized
              in the knowledge base, the queries retrieving the knowledge could
              be patched so that they return the results as if the default values
              were present.</li>
            <li>Normalize the TD: The TD specification can define a set of rules
              that have to be applied to all incoming TD documents in a
              preprocessing step.</li>
        </p>
        <p>
          Normalizing the TD in a preprocessing step also helps for robustness.
          Thus, this is a favorable solution.
        </p>
        <p>
          <a href="https://json-ld.org/spec/latest/json-ld-framing/">JSON-LD&nbsp;1.1 Frameing</a> can be used to define and apply the preprocessing steps.
        </p>
        <p>
          <b>NOTE:</b> Even with JSON-LD 1.1 available, there are still open issues.
          For instance, the object key becomes the <code>@id</code> of the Property node defined in the object value:
          To derive sensible triples, the object key would need to be declared either as "blank node" by prefixing with <code>_:</code>,
          or the container mechanism must be able generate relative <code>@id</code>s to avoid conflicts when an object key appears twice at different levels.
        </p>
      </section>

      <section>
        <h2>Media Type</h2>
        <p>
          When TDs are not a valid JSON-LD document due to necessary preprocessing or simply an omitted <code>@context</code>,
          they need their own media type registered with IANA.
        </p>
        <p>
          We propose <code>application/td+json</code>.
        </p>
      </section>

      <section>
        <h2>New Terms</h2>
        <section>
          <h3><code>link</code></h3>
          <p>
            The Working Draft for the Prague 2018 PlugFest already adopted a top-level <code>link</code> field,
            so that a TD can express relations to other Things or other Web resources.
          </p>
          <p>
            Note that because the TD is JSON-LD, such relations were always possible and are actually always expressed for all top-level fields (it is Linked Data).
            Having the term <code>link</code> makes it explicit that the elements included there are actual Web Links to fetchable Web resources,
            opposed to Linked Data URIs ("IRIs") that are often only an identifier without an actual Web resource.
          </p>
        </section>
        <section>
          <h3><code>description</code></h3>
          <p>
            The term <code>description</code> is very useful and shall become part of the TD core vocabulary for both Thing and Interactions.
          </p>
        </section>
        <section>
          <h3><code>name</code></h3>
          <p>
            The term <code>name</code> would not be the identifier for Interactions anymore.
            Following JSON-LD 1.1, the object key would become <code>@id</code>, which would serve as handle to select Interactions, e.g., for the Scripting API.
          </p>
          <p>
            With that, <code>name</code> becomes either obsolete or rather could be used as optional, human-readible label.
            As a result, for Things, <code>name</code> becomes a mandatory label.
            For Interactions, the new, optional term <code>label</code> is used.
          </p>
        </section>
        <section>
          <h3><code>id</code></h3>
          <p>
            On the top level, <code>id</code> will become important for security and identity management.
            It identifies the instance of Thing and also serves as the <code>@base</code> for all other <code>@id</code> definitions (e.g., of Interactions).
            Only this fully enables the object notation of Interactions (opposed to the previous array notation).
            The top-level <code>id</code> must be mandatory and internally maps to the <code>@id</code> of the Thing.
            Therefore, a Thing <code>id</code> must be a URI (which includes URNs).
          </p>
          <p>
            For Interactions, <code>@id</code> would be the handle for scripts and it would
            enable references to and between Interactions, e.g., for
            cross-Property constraints or for expressing relations between an
            action and one or more Properties. Note that this would result
            automatically from the object structure listing Interactions
            because of JSON-LD 1.1 (<a href="https://json-ld.org/spec/latest/json-ld/#node-identifier-indexing">Node Identifier Indexing</a>).
          </p>
        </section>
      </section>
      
      <section>
        <h2>Model Changes</h2>
        
        <p>
          To enable alignment with other technologies such as JSON Schema, the Simplified TD needs a few small changes to the TD core model.
          It has to be evaluated if these changes are actually breaking changes (i.e., a JSON-LD 1.0 TD would create different triples than a Simplified TD).
        </p>
        
        <section>
          <h3>Properties</h3>
          <p>
            Using the term <code>properties</code> also for the object field names of complex Properties (i.e., <code>"type": "object"</code>) aligns the TD with JSON Schema syntax.
            This results in recursive Properties, where
            <ul>
              <li>Properties also have the <code>DataSchema</code> RDF-type</li>
              <li>Only properties that have a <code>forms</code> field are Interaction Properties.</li>
              <li>Sub-properties of complex Properties might be directly addressable and accessible, when they have the <code>forms</code> field.
            </ul>
          </p>
        </section>
      </section>
      
      <section>
        <h2>Simplified TD by Example</h2>
        
        <p>
          When no <code>@context</code> is given, the <a href="https://w3c.github.io/wot-thing-description/proposals/simplified-td/w3c-wot-td-context.jsonld">Simplified TD context</a>
          is assumed based on the media type (file location needs update for adoption).
          The current TD context also needs an additional definition of <code>@base</code> set to the Thing's <code>@id</code>,
          so that the object representation of Interactions produces correct <code>@id</code>s for the Interactions.
        </p>

        <pre class="example" title="Default context applied to application/td+json">
{
  "@context": {
    /* enable JSON-LD 1.1 processing */
    "@version": 1.1,
    /* valid @id generation relative to Thing instance */
    "@base": "@id",
    /* object notation for Interactions */
    "properties": {
      "@container": "@id"
    },
    "actions": {
      "@container": "@id"
    },
    "events": {
      "@container": "@id"
    },
    /* optional if schema definitions are wanted */
    "definitions": {
      "@container": "@id"
    },
    /* TD term definitions as in https://w3c.github.io/wot/w3c-wot-td-context.jsonld */
    ...
  }
}
        </pre>
        
        <p>
          When <code>@context</code> is given, the <a href="https://w3c.github.io/wot-thing-description/proposals/simplified-td/w3c-wot-td-context.jsonld">Simplified TD context</a>
          is applied last to ensure that the terms of the TD core vocabulary are valid and not shadowed by other contexts.
        </p>
	      
        <section>
          <h3>Minimal Simplified TD</h3>

          <p>
            The first example reflects the minimal option.
            It contains no semantic annotations, nor human-readible decorators such as <code>name</code> or <code>description</code>.
          </p>
          
          <pre class="example" title="Minimal Simplified TD">
{
  "name": "Lamp",
  "id": "urn:dev:wot:com:example:servient:lamp",
  "base": "https://servient.example.com/",
  "properties": {
    "on": {
      "type": "boolean",
      "forms": [{
        "href": "/things/lamp/properties/on",
        "mediaType": "application/json"
      }]
    },
    "status": {
      "readOnly": true,
      "type": "object",
      "properties": {
        "battery": {
          "type": "number",
          "minimum": 0.0,
          "maximum": 100.0,
          "forms": [{
            "href": "/things/lamp/properties/status/batt",
            "mediaType": "application/json"
          }]
        },
        "rssi": {
          "type": "number",
          "minimum": 0.0,
          "maximum": 1.0
        },
        "level": {
          "type": "integer",
          "minimum": 0,
          "maximum": 100
        }
      },
      "forms": [{
        "href": "/things/lamp/properties/status",
        "mediaType": "application/json"
      }]
    },
    "brightness": {
      "type": "integer",
      "minimum": 0,
      "maximum": 100
      "forms": [{
        "href": "/things/lamp/properties/status",
        "mediaType": "application/json"
      }]
    }
  },
  "actions": {
    "fade": {
      "input": {
        "type": "object",
        "properties": {
          "from": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          },
          "to": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          },
          "duration": { "type": "number" }
        }
      },
      "forms": [{
        "href": "/things/lamp/actions/fade",
        /* encType would be for the request body
           opposed to mediaType, which is for target
           FIXME: can have both meanings based on context (links/forms)? */
        "encType": "application/json",
        "mediaType": "application/json"
      }]
    }
  },
  "events": {
    "overheated": {
      "type": "object",
      "properties": {
        "temperature": { "type": "number" }
      },
      "forms": [{
        "href": "/things/lamp/events/overheated",
        /* needed, alternative: register URI schemes "http+sse", "http+lp", ... */
        "http:subProtocol": "http:EventSource",
        "mediaType": "application/json"
      }]
    }
  },
  "links": [{
    "href": "https://servient.example.com/things/motion-detector",
    "rel": "controlledBy",
    "mediaType": "application/td"
  }]
}
          </pre>
        </section>
	      
        <section>
          <h3>Annotated Simplified TD (with semantics)</h3>
          
          <pre class="example" title="Annotated Simplified TD">
{
  "name": "Lamp",
  "description": "Corner torchiere",
  "id": "urn:dev:wot:com:example:servient:lamp",
  "base": "https://servient.example.com/",
  "definitions": {
    "range": {
      "type": "integer",
      "minimum": 0,
      "maximum": 100
    }
  },
  "properties": {
    "on": {
      "label": "On/Off",
      "description": "Power switch"
      "type": "boolean",
      "forms": [{
        "href": "/things/lamp/properties/on",
        "mediaType": "application/json"
      }]
    },
    "status": {
      "readOnly": true,
      "type": "object",
      "properties": {
        "battery": {
          "type": "number",
          "minimum": 0.0,
          "maximum": 100.0,
          "forms": [{
            "href": "/things/lamp/properties/status/batt",
            "mediaType": "application/json"
          }]
        },
        "rssi": {
          "type": "number",
          "minimum": 0.0,
          "maximum": 1.0
        },
        "level": "range"
      },
      "forms": [{
        "href": "/things/lamp/properties/status",
        "mediaType": "application/json"
      }]
    },
    "brightness": {
      /* FIXME: how to reference "range" to import defintions at this level */
      "forms": [{
        "href": "/things/lamp/properties/status",
        "mediaType": "application/json"
      }]
    }
  },
  "actions": {
    "fade": {
      "input": {
        "type": "object",
        "properties": {
          "from": "range",
          "to": "range",
          "duration": { "type": "number" }
        }
      },
      "forms": [{
        "href": "/things/lamp/actions/fade",
        /* encType would be for the request body
           opposed to mediaType, which is for target
           FIXME: can have both meanings based on context (links/forms)? */
        "encType": "application/json",
        "mediaType": "application/json",
        /* redundant to default here, just to indicate
           imagine a PATCH Action or a CoAP FETCH Action */
        "http:methodName": "POST"
      }]
    }
  },
  "events": {
    "overheated": {
      "type": "object",
      "properties": {
        "temperature": { "type": "number" }
      },
      "forms": [{
        "href": "/things/lamp/events/overheated",
        /* needed, alternative: register URI schemes "http+sse", "http+lp", ... */
        "http:subProtocol": "http:EventSource",
        "mediaType": "application/json"
      }]
    }
  },
  "links": [{
    "href": "https://servient.example.com/things/motion-detector",
    "rel": "controlledBy",
    "mediaType": "application/td"
  }]
}
          </pre>
        </section>
        
      </section>
    </section>

    <section>
      <h1>JSON-LD 1.0 TD</h1>
      
        <p>This section summerizes the status of the JSON-LD 1.1 based Thing Description (until Prague 2018 WD).</p>
      
        <section>
          <h2>JSON-LD 1.0 TD by Example</h2>
          
          <section>
            <h3>Minimal JSON-LD</h3>

            <p>
              This example reflects the minimal option.
              It contains no semantic annotations, nor human-readible decorators such as <code>name</code> or <code>description</code>.
            </p>

            <pre class="example" title="Minimal JSON-LD 1.0 TD">
  {
    "@context": "https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
    "name": "Lamp",
    "@id": "urn:dev:wot:com:example:servient:lamp",
    "base": "https://servient.example.com/",
    "interactions": [{
      "@type": "Property",
      "name": "on",
      "writeable": true,
      "schema": { "type": "boolean" },
      "forms": [{ "href": "/things/lamp/properties/on" }]
    }, {
      "@type": "Property",
      "name": "brightness",
      "writeable": true,
      "schema": {
        "type": "number",
        "minimum": 0,
        "maximum": 100
      },
      "forms": [{ "href": "/things/lamp/properties/brightness" }]
    }, {
      "@type": "Action",
      "name": "fade",
      "inputSchema": {
        "type": "object",
        "fields": [{
          "name": "from",
          "schema": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          }
        }, {
          "name": "to",
          "schema": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          }
        }, {
          "name": "duration",
          "schema": { "type": "number" }
        }]
      },
      "forms": [{ "href": "/things/lamp/actions/fade" }]
    }, {
      "@type": "Event",
      "name": "overheated",
      "schema": {
        "type": "object",
        "fields": [{
          "name": "temperature",
          "schema": { "type": "number" }
        }]
      },
      "forms": [{ "href": "/things/lamp/events/overheated" }]
    }],
    "links": [{
      "href": "https://servient.example.com/things/motion-detector",
      "rel": "controlledBy",
      "mediaType": "application/td"
    }]
  }
            </pre>

          </section>
          <section>
            <h3>Annotated JSON-LD 1.0 TD</h3>
  <!--
            <pre class="example" title="JSON-LD 1.0 TD with semantic annotations">
  {
    "@context": [
      "https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
      { "iot": "http://iotschema.org/" },
      { "http": "http://iotschema.org/protocol/http#" }
    ],
    "definitions": { /* optional if wanted! for free by JSON-LD */
      "range": {
        "@type": ["iot:LevelData"],
        "type": "integer",
        "minimum": 0,
        "maximum": 100
      }
    },
    "@type": ["Thing", "iot:Light", "iot:BinarySwitch", "iot:LevelCapability"],
    "name": "lamp",
    "description": "A Web-connected lamp",
    "@id": "urn:dev:wot:com:example:servient:lamp",
    "base": "https://servient.example.com/",
    "properties": {
      "on": {
        "name": "On/Off",
        "description": "Whether the lamp is turned on",
        "@type": ["iot:SwitchStatus"],
        "writable": true,
        "observable": true,
        "schema": {
          "@type": ["iot:SwitchData"],
          "type": "boolean"
        },
        "forms": [{
          "href": "/things/lamp/properties/on",
          "rel": ["get", "set"]
        }, {
          "href": "/things/lamp/properties-push/on",
          "rel": ["observe"],
          "http:SubProtocol": "http:ServerSentEvents"
        }]
      },
      "brightness": {
        "name": "Brightness",
        "description": "The level of light from 0-100",
        "@type": ["iot:CurrentLevel"],
        "writable": true,
        "observable": true,
        "schema": "range",
        "forms": [{
          "href": "/things/lamp/properties/brightness",
          "rel": ["get", "set"]
        }, {
          "href": "/things/lamp/properties-push/brightness",
          "rel": ["observe"],
          "http:SubProtocol": "http:ServerSentEvents"
        }]
      }
    },
    "actions": {
      "fade": {
        "name": "Fade",
        "description": "Fade from one level to another",
        "@type": ["iot:SetLevel"],
        "inputSchema": {
          "type": "object",
          "fields": [{
            "name": "from",
            "schema": "range",
          }, {
            "name": "to",
            "schema": "range",
          }, {
            "name": "duration",
            "@type": ["iot:TransitionTimeData"],
            "schema": { "type": "number" }
          }]
        },
        "forms": [{ "href": "/things/lamp/actions/fade" }]
      }
    },
    "events": {
      "overheated": {
        "schema": {
          "type": "object",
          "fields": [{
            "name": "temperature",
            "schema": { "type": "number" }
          }]
        },
        "forms": [{
          "href": "/things/lamp/events/overheated",
          "http:subProtocol": "http:EventSource"
        }]
      }
    },
    "links": [{
      "href": "https://servient.example.com/things/motion-detector",
      "rel": "controlledBy",
      "mediaType": "application/td"
    }]
  }
            </pre>
-->
        </section>
      </section>
    </section>

    <section>
      <h1>JSON Web Thing Description (JSON-TD)</h1>
      <p>
        The following JSON example was build from snippets taken from <a href="https://w3c.github.io/wot/proposals/json-td/index.html">here</a>.
      </p>

      <section>
        <h2>JSON-TD by Example</h2>

        <pre class="example" title="JSON-TD Example">
{
  "name": "My Lamp",
  "type": "thing",
  "description": "A web connected lamp",
  "properties": {
    "on": {
      "type": "boolean",
      "description": "Whether the lamp is turned on",
      "href": "/things/lamp/properties/on"
    },
    "brightness": {
      "type": "number",
      "description": "The level of light from 0-100",
      "minimum": 0,
      "maximum": 100,
      "href": "/things/lamp/properties/brightness"
    }
  },
  "actions": {
    "fade": {
      "name": "Fade",
      "description": "Fade from one brightness to another",
      "data": {
        "from": {
          "type": "number",
          "minimum": 0,
          "maximum": 100
        },
        "to": {
          "type": "number",
          "minimum": 0,
          "maximum": 100
        },
        "duration": {
          "type": "number",
          "unit": "milliseconds"
        }
      },
      "href": "/things/lamp/actions/fade"
    }
  },
  "events": {
    "overheated": {
      "name": "Overheated",
      "description": "The device exceeded its maximum safe operating temperature",
      "data": {
        "temperature": {
          "type": "number",
          "unit": "celcius"
        }
      }
    }
  },
  "links": {
    "properties": "/thing/lamp/properties",
    "actions": "/things/lamp/actions",
    "events": "/things/lamp/events"
  }
}
        </pre>
      </section>
    </section>

    <section>
      <h1>Comparing "Progressive Simplified TD" to "JSON-TD"</h1>
      <ul>
        <li>Has markup for writable and observable</li>
        <li>Data schema of Properties is put into a <code>schema</code> sub-field
          <ul>
            <li>Allows referencing defined types</li>
            <li>Helps to cluster potentially complex schema definitions</li>
            <li>Similar to Actions and Events</li>
          </ul>
        </li>
        <li>Data schema of Actions is put into a <code>schema</code> sub-field, not <code>data</code>
          <ul>
            <li>Similar to Properties and Events</li>
          </ul>
        </li>
        <li>Action parameters are put into a single schema
          <ul>
            <li>Explicitly models marshalling of multiple parameters</li>
            <li>Matches body/payload based paradigm of Web protocols</li>
          </ul>
        </li>
        <li>Data schema of Events is put into a <code>schema</code> sub-field, not <code>data</code>
          <ul>
            <li>Similar to Properties and Actions</li>
          </ul>
        </li>
        <li>URI etc. is put into a <code>forms</code> sub-field
          <ul>
            <li>Allows for alternate URIs</li>
            <li>Serves as clean extension point for protocol bindings</li>
          </ul>
        </li>
        <li>Links are used to link to external related Web resources</li>
        <li>(Data schema is fully defined)</li>
        <li>(Option for semantic annotations)</li>
      </ul>
    </section>

  </body>
</html>
