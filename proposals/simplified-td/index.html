<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Simplified WoT Thing Description</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
    <script class="remove">
      var respecConfig = {
        specStatus: "ED"
      , processVersion: 2017
		  , shortName: "wot-thing-description-simplified"
      , wg:             "Web of Things Working Group"
      , wgURI:          "https://www.w3.org/WoT/WG/"
		  , edDraftURI : "https://w3c.github.io/wot-thing-description/proposals/simplified-json-ld/index.html"
      , editors: [{
          name: "Matthias Kovatsch",
          company: "Siemens AG"
        },{
          name: "Sebastian Kaebisch",
          company: "Siemens AG"
        },{
          name: "Daniel Peintner",
          company: "Siemens AG"
        }]
      , charterDisclosureURI: 'https://www.w3.org/2016/07/wot-wg-charter.html#patentpolicy'
      };
    </script>
    <style>
      table{
          width: 100%;
          border: solid 1px #005A9C;
          border-collapse: collapse;
      }
      th{
          background-color: #005A9C;
          color: white;
      }
      td,
      th{
          border: solid 1px #005A9C;
          padding: 4px;
      }</style>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document summarizes the discussions on simplifying the <a href="https://w3c.github.io/wot-thing-description/">WoT Thing Description</a>.
        It lists the features of the current JSON-LD serialization and gives use cases per feature.
        The proposal of a simplified TD serialization is given in the form of extensive examples.
        Specification text will be added if the proposal finds acceptance; the editorial work is then most likely continuing in the
        Working Group's <a href="https://w3c.github.io/wot-thing-description/">WoT Thing Description</a> draft itself.
        For convenience, an example from the alternative <a href="https://w3c.github.io/wot/proposals/json-td/index.html">JSON Web Thing Description</a>
        (a.k.a. JSON-TD) is included here.
        The documents concludes with a list of differences in the proposals.
      </p>
    </section>

    <section id="sotd">
      <p> </p>
    </section>

    <section>
      <h1>Introduction</h1>
      <p>
      </p>
    </section>

    <section>
      <h1>TD Features and Use Cases</h1>
      <p>
        Most of the discussions are rooted on the question of a certain feature should be included or not.
        This section lists the features currently included in the <a href="https://w3c.github.io/wot-thing-description/">WoT Thing Description</a>
        and backs them by use cases.
      </p>

      <section>
        <h2>Interaction Model</h2>
        <p>
          To represent a contract between applications with programming APIs
          and IoT devices with network APIs, communication with Things must be
          modeled with a formal interaction model. This describes not only what
          data a Thing provides or requires, but also <emph>how</emph> this data
          can be accessed and manipulated.
        </p>
        <p>
          Besed on the <a href="https://www.w3.org/Submission/wot-model/">Web Thing Model</a>
          and results of the <a href="http://www.compose-project.eu/">COMPOSE project</a>
          the WoT Interest Group explored a threefold of Interactions, which was
          adopted by the WoT Working Group after 2 years of stability:
        </p>
        <section>
          <h3>Properties</h3>
          <p>
            Properties expose internal state of a Thing that can be directly
            accessed (get) and potentially manipulated (set). Things can also
            choose to make Properties observable by pushing the new state after
            a change; this should follow eventual consistency (also see
            <a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP Theorem</a>).
          </p>
          <ul>
            <li>Read-only Properties: state cannot be changed from the outside
              <ul>
                <li>sensors</li>
                <li>results computed from internal state</li>
              </ul>
            </li>
            <li>Writeable Properties: state needs to changed from the outside
              <ul>
		<li>intended state can be applied to actual state immediately</li>
		<li>configuration state</li>
                <li>setpoints</li>
		<li>better grouping / more concise model</li>
              </ul>
            </li>
            <li>Observable Properties: optimize communication through server push
              <ul>
                <li>keep state in sync with relaxed consistency (eventual consistency)</li>
                <li>directly maps to CoAP Observe</li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h3>Actions</h3>
          <p>
            Actions offer function of the Thing. These functions manipulate the
            interal state of Thing in a way that is not possible through setting
            Properties. Examples are changing internal state that is not exposed
            as Property, changing multiple Properties, changing Properties over
            time or with a process that shall not be disclosed.
          </p>
          <ul>
            <li>Action arguments: the function needs input parameters
              <ul>
                <li>functions with parameters</li>
		<li>write-multiple commands</li>
              </ul>
            </li>
            <li>Action results: the function returns a result
              <ul>
                <li>(sensors that are not based on sampling / fit for Properties)</li>
                <li>(calibration reports)</li>
                <li>read-multiple commands</li>
              </ul>
            </li>
            <li>Monitorable Actions: process can be monitored, changed, canceled once invoked
              <ul>
                <li>progress bars</li>
                <li>long-lasting processes</li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h3>Events</h3>
          <p>
            Events are asynchronous push interactions by the server. Here not
            state, but state transitions (events) are communicated.
            Events are usually triggered when through conditions that are not
            exposed as state (Properties). This usually follows strong consistency
            where messages need to be queued to ensure eventual delivery of all
            occured events.
          </p>
          <ul>
            <li>Events opposed to observable Properties: why two mechanisms
              <ul>
                <li>Events triggered by state that is not exposed through Properties</li>
                <li>Separation of consistency requirements</li>
                <li>Duality of REST and PubSub systems</li>
              </ul>
            </li>
            <li>Actionable Events: Event not only has data but also Interactions
              <ul>
                <li>alerts that need to be confirmed, marked as resolved</li>
              </ul>
            </li>
          </ul>
        </section>
      </section>

      <section>
        <h2>Data Schema</h2>
        <p>
          The Web of Things is supposed to make IoT technology more usable,
          which includes usability for developers. This is fundamental to the
          success of Web Technology in general.
        </p>
        <p>
          This requirement lead to the choice of a JSON-based format for the TD.
        </p>
        <section>
          <h3>JSON</h3>
          <p>
            JSON reflects the state of the art of data interchange formats.
            It is not focused on how data is represented by a specific system
            (e.g., in 16 bits), but only on the fundamentals of the information.
          </p>
          <ul>
            <li>Dominant data format on the Web</li>
            <li>Implementation-independent representation of data</li>
          </ul>
        </section>
        <section>
          <h3>JSON Schema</h3>
          <p>
            JSON is a generic representation format and cannot convey the syntax
            of application-specific formats. JSON Schema provides the required
            validation features.
          </p>
          <ul>
            <li>Rich vocabulary for validation</li>
            <li>Popular schema format</li>
          </ul>
        </section>
        <section>
          <h3>Linked Data / JSON-LD Schema</h3>
          <p>
            Directly using the JSON Schema syntax within the TD breaks paradigms.
            Two different implementations would be needed to conduct validation.
            At least JSON Schema could be reused.
            However, semantic queries and resoning could not work on data structures,
            that is, make sense of the data in relation to the Thing and its
            context.
          </p>
          <ul>
            <li>Re-use of JSON Schema vocabulary</li>
            <li>Enable validation through JSON-LD</li>
          </ul>
        </section>
      </section>

      <section>
        <h2>Web Linking</h2>
        <p>
          The TD now has a top-level <code>link</code> field to carry links to
          other Web resources.
        </p>
        <ul>
          <li>
            In a deployment, Things usually have relations to other Things or
            entities such as locations, which may have metadata representations
            on their own.
          </li>
          <li>
            In the future, additional metadata might be provided as externalized
            Web resource, just like done for HTML or the Web Linking header field.
          </li>
        </ul>
      </section>

      <section>
        <h2>Security Metadata</h2>
        <p>
          The TD has a top-level <code>security</code> field to carry security
          metadata such as the required authorization mechanism, authorization
          server, required root certificates, etc.
        </p>
          <ul>
            <li>Security</li>
            <li>Share controlled acccess to the Thing (authorization, e.g., OAuth)</li>
          </ul>
      </section>

      <section>
        <h2>Communication Metadata</h2>
        <p>
          The TD Interactions have a <code>form</code> field to carry protocol-specific
          metadata such as method used and header fields required. The concept of
	  machine understandable forms matches the requirement of RAML, Swagger, OpenAPI
	  for RESTful Web APIs.
        </p>
        <p>
          The W3C Web of Things was charted to counter the fragmentation in the
          IoT. Creating yet another standard does not help here, as existing
          standards with strong domain-specific knowledge have shown to hold out.
          Thus, W3C WoT was charted to describe and complement existing IoT
          platforms and standards. For this, a TD must be able to describe
          how a client can communicate successfully with a server.
        </p>
        <section>
          <h3>Request Metadata</h3>
          <p>
            Up to date, not even so-called RESTful Web services managed to follow
            a single guidline when designing their API. Requests always have to
            be tailored for each service.
          </p>
          <p>
            To relect this situation in the TD, where are similar picture is
            expected for Things, a TD is able to include so called form descriptions,
            which go beyond Web linking: The not only describe the relation to
            a target resource and attributes of the target resource, but also
            descriptions how to interact with that resource, that is, how a
            client has to formulate requests (e.g., header fields or payloads).
          </p>
          <ul>
            <li>Compensate for small variations in methods</li>
            <li>Compensate for small variations in header fields</li>
          </ul>
        </section>
        <section>
          <h3>Extension Point</h3>
          <p>
            So far, there is no single IoT protocol to rule them all. The only
            convergence visible is a trend toward Internet protocols defined by
            the IETF and other bodies such as OASIS. Yet still every IoT platform
            and standard tends to introduce small variations, thereby creating
            protocol dialects.
          </p>
          <p>
            To allow for convergence of currently deployed IoT protocols and to
            be future proof for new protocols that might emerge as de facto
            standards, the TD has protocol bindings as explicit extension point.
          </p>
          <ul>
            <li>Use HTTP long-poll for Events</li>
            <li>Use HTTP Server-Sent Events for Events</li>
            <li>Use WebSocket sub-protocols that do not have a URI scheme</li>
            <li>Use CoAP dialects such as OCF or oneM2M</li>
            <li>Use protocols of large IoT platforms such as Amazon IoT or Azure IoT</li>
          </ul>
        </section>
        <section>
          <h3>Binding Templates</h3>
          <p>
            The <a href="https://w3c.github.io/wot-binding-templates/">WoT Binding Templates</a>
            document serves as catalog to pick the right communication metadata
            for well-known IoT protocols. The templates provide vocabulary to
            describe the required protocol stack configuration (e.g., specific
            header fields) and security mechanisms in the TD.
          </p>
          <p>
            Binding Templates are mainly expected for dialects of the Web protocols
            HTTP/1.1, HTTP/2, and CoAP, standardized sub-protocols for WebSockets,
            and widely deployed IoT protocols such as AMQP or MQTT profiles
            (e.g., Amazon IoT).
          </p>
          <ul>
            <li>Provide a common vocabulary for communication metadata</li>
          </ul>
        </section>
      </section>

      <section>
        <h2>Semantic Annotations</h2>
        <p>
          The Web of Things is centered on things. During runtime, data and
          metadata are primarily exchanged among machines for machines.
          Furthermore, WoT content is produced by a large number of machines.
          Thus, machine assistance is also needed for consuming the data and
          bulding viable business cases.
        </p>
        <section>
          <h3>Annotation Framwork</h3>
          <p>
            Semantic annotations are based on JSON-LD, which gives meaning to
            JSON field names and values by defining the terms used in the
            <code>@context</code> and linking them to Link Data.
            TDs can be annotated as follows:
          </p>
          <ul>
            <li>Thing types in the top-level <code>@type</code> array</li>
            <li>Thing capabilities</li>
            <li>Thing metadata in additional top-level fields that follow the
              rules of JSON-LD</li>
            <li>Interaction types in the <code>@type</code> array within Interaction elements</li>
            <li>Interaction metadata in additional sub-fields that follow the
              rules of JSON-LD</li>
            <li>Data types in the <code>@type</code> array within <code>schema</code></li>
          </ul>
        </section>
        <section>
          <h3>Extension Point</h3>
          <p>
            The W3C has no knowledge in the concrete application domains of Web
            of Things. Thus, the W3C is not standardizing any domain-specific
            vocabulary.
          </p>
          <p>
            Still, domain-specific vocabularies are of utmost importance for
            semantic interoperability. Thus, the TD has an explicit extension
            point that comes for free when using JSON-LD and Linked Data.
          </p>
        </section>
      </section>

    </section>

    <section>
      <h1>Serialization Requirements</h1>
      <p>
      </p>

      <section>
        <h2>Human-readability</h2>
        <p>
          The Web of Things is supposed to make IoT technology more usable,
          which includes usability for developers. This is fundamental to the
          success of Web Technology in general.
        </p>
        <p>
          This requirement lead to the choice of a JSON-based format for the TD.
        </p>
      </section>

      <section>
        <h2>Machine-understandability</h2>
        <p>
          The Web of Things is centered on things. During runtime, data and
          metadata are primarily exchanged among machines for machines.
          Furthermore, WoT content is produced by a large number of machines.
          Thus, machine assistance is also needed for consuming the data and
          bulding viable business cases.
        </p>
        <p>
          Thus, TDs must not only be machine-readible, but machine-understandable.
          Moreover, the TD metadata can help to make optimized runtime data
          (i.e., no metadata included in the live data exchanged)
          also machine-understandable.
        <p>
          This requirement lead to the choice of JSON-LD, an existing W3C standard
          for machine-understandable JSON documents based on Linked Data vocabularies.
        </p>
      </section>

      <section>
        <h2>Introspection</h2>
        <p>
          Applications consuming TDs should be able to easily introspect the
          capabilites, possible interactions, and other metadata of the corresponding
          Things.
        </p>
        <p>
          In particular the <a href="https://w3c.github.io/wot-scripting-api/">WoT Scripting API</a>
          benefits from an alternative structure of the TD, such as separated
          entry points for Properties, Actions, and Events.
        </p>
      </section>

      <section>
        <h2>Default Values</h2>
        <p>
          Implementations for the PlugFest showed that basically every developer
          is counting on defaults, that is, certain elements can be omitted as
          their meaning is known implicitly or even irrelevant. Examples are
          omitting the <code>security</code> metadata for test Things that use
          no-security, omitting the <code>writeable</code> flag for read-only
          Properties, or omitting <code>inputSchema</code>/<code>outputSchema</code>
          for Actions that do not take arguments and/or return nothing.
        </p>
        <p>
          Treating the JSON-LD TD strictly as Linked Data document, a collection
          of triples, would not allow for such defaults, and hence convenience.
          Linked Data underly the
          <a href="https://en.wikipedia.org/wiki/Open-world_assumption">open-world assumption</a>.
          That means, when a TD is omitting statements (e.g., writeable flag),
          then the consumer cannot make any assumptions about its actual value.
        </p>
        <p>
          Based on the knowledge that it is a TD, the consumer could, however,
          apply a set rules, which infer the defaults. This leads to the
          preprocessing introduced in the next section.
        </p>
      </section>

      <section>
        <h2>Robustness Principle</h2>
        <p>
          Be conservative in what you do, be liberal in what you accept from others.
          Applying <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel's law</a>
          fosters interoperability and should also be used in the Web of Things.
        </p>
        <p>
          This requirement also leads to a preprocessing step that can fill in
          defaults and correct minor issues.
        </p>
      </section>
    </section>

    <section>
      <h1>Simplified TD</h1>
      <p>
        The direction toward a simplified TD was opened during TPAC 2017 (Burlingame)
        and is based on the latter two (or three) requirements given in the
        previous section.
      </p>

      <section>
        <h2>Preprocessing</h2>
        <p>
          The main change and enabler for a simplified TD is introducing a
          preprocessing step.
        </p>
        <p>
          Due to the <a href="https://en.wikipedia.org/wiki/Open-world_assumption">open-world assumption</a>,
          some processing of the TD is required. The rules to fill in defaults
          could be applied in the following way:
          <ul>
            <li>Custom rules: If semantic support through queries and reasoners
              is not used, simple hard-coded rules can fill in the defaults when
              the internal model of the implementation is created. A drawback is
              that this hinders common, re-usable tooling.</li>
            <li>Rule languages: Most knowledge bases have support for rule
              languages, which could create the missing triples for the defaults.
              A drawback is that there is no one standard that would be available
              in all knowledge bases.</li>
            <li>Query rewriting: Instead of having the default triples materialized
              in the knowledge base, the queries retrieving the knowledge could
              be patched so that they return the results as if the default values
              were present.</li>
            <li>Normalize the TD: The TD specification can define a set of rules
              that have to be applied to all incoming TD documents in a
              preprocessing step.</li>
        </p>
        <p>
          Normalizing the TD in a preprocessing step also helps for robustness.
          Thus, this is a favorable solution.
        </p>
        <p>
          When preprocessing becomes part of the TD specification, then it can
          be extended to other rules, e.g., format cosmetics. The number and
          complexity of these rules, however, must be kept low to ensure robustness,
          and hence interoperability.
        </p>
        <p>
          Format cosmetics could include JSON-LD 1.1 features, while JSON-LD 1.1
          is not a standard yet. This includes the "object vs array" discussion
          point, where elements of, for instance, <code>properties</code> shall
          be given within an object where the key carries the name of the Property.
        </p>
        <p>
          <b>NOTE:</b> Even with JSON-LD 1.1 available, this would not work directly.
          To derive sensible triples, the object key would need to be declared
          as "blank node" by prefixing with <code>_:</code>, as the object key
          becomes the <code>@id</code> of the Property defined in the value.
          In short: Even with JSON-LD 1.1 we need a preprocessing step.
        </p>
      </section>

      <section>
        <h2>Media Type</h2>
        <p>
          When TDs are not a valid JSON-LD document due to necessary preprocessing
          or simply an omitted <code>@context</code>, they need their own media
          type registered with IANA.
        </p>
        <p>
          We propose <code>application/td+json</code>.
        </p>
      </section>

      <section>
        <h2>New Terms</h2>
        <section>
          <h3><code>link</code></h3>
          <p>
            The Working Draft for the Prague 2018 PlugFest already adopted a
            top-level <code>link</code> field, so that a TD can express relations
            to other Things or other Web resources.
          </p>
          <p>
            Note that because the TD is JSON-LD, such relations were always
            possible and are actually always expressed for all top-level fields
            (it is Linked Data). Having the term <code>link</code> makes it
            explicit that the elements included there are actual Web Links to
            fetchable Web resources, opposed to Linked Data URIs ("IRIs") that
            are often only an identifier without an actual Web resource.
          </p>
        </section>
        <section>
          <h3><code>description</code></h3>
          <p>
            The term <code>description</code> is very useful and shall become
            part of the TD code vocabulary.
          </p>
        </section>
        <section>
          <h3><code>name</code></h3>
          <p>
            The term <code>name</code> would not be the identifier for Interactions
            anymore. Following JSON-LD 1.1, the object key would become <code>@id</code>,
            which still can serve as handle to select Interactions, e.g., for
            the Scripting API.
          </p>
          <p>
            With that, <code>name</code> becomes either obsolete or rather could
            be used as optional, human-readible label. This might be a bit
            problematic when the Thing's name is used to build the URI paths on
            Servients. Thing names would need conventions or we just live with
            ugly (percent-encoded) URIs.
          </p>
        </section>
        <section>
          <h3><code>@id</code></h3>
          <p>
            On the top level, <code>@id</code> will become important for
            security and identity management. It should be mandatory.
          </p>
          <p>
            For Interactions, it would be the handle for scripts and it would
            enable references to and between Interactions, e.g., for
            cross-Property constraints or for expressing relations between an
            action and one or more Properties. Note that this would result
            automatically from the object structure for listing Interactions
            because of JSON-LD 1.1.
          </p>
          <p>
            The JSON-LD default term <code>@id</code> can be masked with a
            TD-defined, and hence plain term such as <code>id</code>.
          </p>
        </section>
      </section>

      <section>
        <h2>Simplified TD by Example</h2>

        <p>
          The first example reflects the most progressive option with the
          highest amount of preprocessing necessary. It contains no semantic
          annotations, nor human-readible decorators such as <code>name</code>
          or <code>description</code>.
        </p>

        <pre class="example" title="Progressive Simplified TD Example">
{
  "name": "lamp",
  "@id": "urn:dev:wot:com:example:servient:lamp",
  "base": "https://servient.example.com/",
  "properties": {
    "on": {
      "writeable": true,
      "schema": { "type": "boolean" },
      "forms": [{ "href": "/things/lamp/properties/on" }]
    },
    "brightness": {
      "writeable": true,
      "schema": {
        "type": "number",
        "minimum": 0,
        "maximum": 100
      },
      "forms": [{ "href": "/things/lamp/properties/brightness" }]
    }
  },
  "actions": {
    "fade": {
      "inputSchema": {
        "type": "object",
        "fields": [{
          "name": "from",
          "schema": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          }
        }, {
          "name": "to",
          "schema": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          }
        }, {
          "name": "duration",
          "schema": { "type": "number" }
        }]
      },
      "forms": [{ "href": "/things/lamp/actions/fade" }]
    }
  },
  "events": {
    "overheated": {
      "schema": {
        "type": "object",
        "fields": [{
          "name": "temperature",
          "schema": { "type": "number" }
        }]
      },
      "forms": [{ "href": "/things/lamp/events/overheated" }]
    }
  },
  "links": [{
    "href": "https://servient.example.com/things/motion-detector",
    "rel": "controlledBy",
    "mediaType": "application/td"
  }]
}
        </pre>

        <pre class="example" title="Simplified TD Example with semantic annotations">
{
  "@context": [
    "https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
    { "iot": "http://iotschema.org/" },
    { "http": "http://iotschema.org/protocol/http#" }
  ],
  "@type": ["Thing", "iot:Light", "iot:BinarySwitch", "iot:LevelCapability"],
  "name": "lamp",
  "description": "A Web-connected lamp",
  "@id": "urn:dev:wot:com:example:servient:lamp",
  "base": "https://servient.example.com/",
  "properties": {
    "on": {
      "name": "On/Off",
      "description": "Whether the lamp is turned on",
      "@type": ["iot:SwitchStatus"],
      "writeable": true,
      "observable": true,
      "schema": {
        "@type": ["iot:SwitchData"],
        "type": "boolean"
      },
      "forms": [{
        "href": "/things/lamp/properties/on",
        "rel": ["get", "set"]
      }, {
        "href": "/things/lamp/properties-push/on",
        "rel": ["observe"],
        "http:SubProtocol": "http:ServerSentEvents"
      }]
    },
    "brightness": {
      "name": "Brightness",
      "description": "The level of light from 0-100",
      "@type": ["iot:CurrentLevel"],
      "writeable": true,
      "observable": true,
      "schema": {
        "@type": ["iot:LevelData"],
        "type": "number",
        "minimum": 0,
        "maximum": 100
      },
      "forms": [{
        "href": "/things/lamp/properties/brightness",
        "rel": ["get", "set"]
      }, {
        "href": "/things/lamp/properties-push/brightness",
        "rel": ["observe"],
        "http:SubProtocol": "http:ServerSentEvents"
      }]
    }
  },
  "actions": {
    "fade": {
      "name": "Fade",
      "description": "Fade from one level to another",
      "@type": ["iot:SetLevel"],
      "inputSchema": {
        "type": "object",
        "fields": [{
          "name": "to",
          "@type": ["iot:LevelData"],
          "schema": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          }
        }, {
          "name": "duration",
          "@type": ["iot:TransitionTimeData"],
          "schema": { "type": "number" }
        }]
      },
      "forms": [{ "href": "/things/lamp/actions/fade" }]
    }
  },
  "events": {
    "overheated": {
      "schema": {
        "type": "object",
        "fields": [{
          "name": "temperature",
          "schema": { "type": "number" }
        }]
      },
      "forms": [{
        "href": "/things/lamp/events/overheated",
        "http:SubProtocol": "http:ServerSentEvents"
      }]
    }
  },
  "links": [{
    "href": "https://servient.example.com/things/motion-detector",
    "rel": "controlledBy",
    "mediaType": "application/td"
  }]
}
        </pre>

        <p>
          An alternative with the array structure to list Interactions would
          look as follows. This would circumvent the issue that Interaction IDs
          would need a <code>_:</code> prefix to make them blank nodes or an
          <code>@base</code> in an always present <code>@context</code>.
          Furthermore, it should be noted that the TD is an interchange format
          that needs to be pared by the recipient. Parsing an array is easier
          than parsing an Object strcuture. The downside is cumbersome
          introspection of a TD pared into a JavaScript object
          (<code>thing.properties[0].schema</code> instead of
          <code>thing.properties.on.schema</code>).
        </p>
        <pre class="example" title="Moderate Simplified TD Example">
{
  "name": "lamp",
  "@id": "urn:dev:wot:com:example:servient:lamp",
  "base": "https://servient.example.com/",
  "properties": [{
    "id": "on",
    "writeable": true,
    "schema": { "type": "boolean" },
    "forms": [{ "href": "/things/lamp/properties/on" }]
  }, {
    "id": "brightness",
    "writeable": true,
    "schema": {
      "type": "number",
      "minimum": 0,
      "maximum": 100
    },
    "forms": [{ "href": "/things/lamp/properties/brightness" }]
  }],
  "actions": [{
    "id": "fade",
    "inputSchema": {
      "type": "object",
      "fields": [{
        "name": "from",
        "schema": {
          "type": "integer",
          "minimum": 0,
          "maximum": 100
        }
      }, {
        "name": "to",
        "schema": {
          "type": "integer",
          "minimum": 0,
          "maximum": 100
        }
      }, {
        "name": "duration",
        "schema": { "type": "number" }
      }]
    },
    "forms": [{ "href": "/things/lamp/actions/fade" }]
  }],
  "events": [{
    "id": "overheated",
    "schema": {
      "type": "object",
      "fields": [{
        "name": "temperature",
        "schema": { "type": "number" }
      }]
    },
    "forms": [{ "href": "/things/lamp/events/overheated" }]
  }],
  "links": [{
    "href": "https://servient.example.com/things/motion-detector",
    "rel": "controlledBy",
    "mediaType": "application/td"
  }]
}
        </pre>
      </section>
    </section>

    <section>
      <h1>JSON Web Thing Description</h1>
      <p>
        The following JSON example was build from snippets taken from <a href="https://w3c.github.io/wot/proposals/json-td/index.html">here</a>.
      </p>

      <section>
        <h2>JSON-TD by Example</h2>

        <pre class="example" title="JSON-TD Example">
{
  "name": "My Lamp",
  "type": "thing",
  "description": "A web connected lamp",
  "properties": {
    "on": {
      "type": "boolean",
      "description": "Whether the lamp is turned on",
      "href": "/things/lamp/properties/on"
    },
    "brightness": {
      "type": "number",
      "description": "The level of light from 0-100",
      "minimum": 0,
      "maximum": 100,
      "href": "/things/lamp/properties/brightness"
    }
  },
  "actions": {
    "fade": {
      "name": "Fade",
      "description": "Fade from one brightness to another",
      "data": {
        "from": {
          "type": "number",
          "minimum": 0,
          "maximum": 100
        },
        "to": {
          "type": "number",
          "minimum": 0,
          "maximum": 100
        },
        "duration": {
          "type": "number",
          "unit": "milliseconds"
        }
      },
      "href": "/things/lamp/actions/fade"
    }
  },
  "events": {
    "overheated": {
      "name": "Overheated",
      "description": "The device exceeded its maximum safe operating temperature",
      "data": {
        "temperature": {
          "type": "number",
          "unit": "celcius"
        }
      }
    }
  },
  "links": {
    "properties": "/thing/lamp/properties",
    "actions": "/things/lamp/actions",
    "events": "/things/lamp/events"
  }
}
        </pre>
      </section>
    </section>

    <section>
      <h1>Comparing "Progressive Simplified TD" to "JSON-TD"</h1>
      <ul>
        <li>Has markup for writeable and observable</li>
        <li>Data schema of Properties is put into a <code>schema</code> sub-field
          <ul>
            <li>Allows referencing defined types</li>
            <li>Helps to cluster potentially complex schema definitions</li>
            <li>Similar to Actions and Events</li>
          </ul>
        </li>
        <li>Data schema of Actions is put into a <code>schema</code> sub-field, not <code>data</code>
          <ul>
            <li>Similar to Properties and Events</li>
          </ul>
        </li>
        <li>Action parameters are put into a single schema
          <ul>
            <li>Explicitly models marshalling of multiple parameters</li>
            <li>Matches body/payload based paradigm of Web protocols</li>
          </ul>
        </li>
        <li>Data schema of Events is put into a <code>schema</code> sub-field, not <code>data</code>
          <ul>
            <li>Similar to Properties and Actions</li>
          </ul>
        </li>
        <li>URI etc. is put into a <code>forms</code> sub-field
          <ul>
            <li>Allows for alternate URIs</li>
            <li>Serves as clean extension point for protocol bindings</li>
          </ul>
        </li>
        <li>Links are used to link to external related Web resources</li>
        <li>(Data schema is fully defined)</li>
        <li>(Option for semantic annotations)</li>
      </ul>
    </section>

  </body>
</html>
