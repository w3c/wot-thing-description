<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Web of Things (WoT) Thing Description</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
    <script class='remove'>
          var respecConfig = {
              specStatus:     "ED"
            , processVersion: 2017
            , shortName:      "wot-thing-description"
            , copyrightStart: 2017
            , noLegacyStyle:  true
            , inlineCSS:      true
            , noIDLIn:        true
            , format:         "markdown"
            , wg:             "Web of Things Working Group"
            , wgURI:          "https://www.w3.org/WoT/WG/"
            , wgPublicList:   "public-wot-wg"
            , edDraftURI:     "https://w3c.github.io/wot-thing-description/"
            , githubAPI:      "https://api.github.com/repos/w3c/wot-thing-description"
            , issueBase:      "https://www.github.com/w3c/wot-thing-description/issues"
            , editors: [
                {
                  name:       "Sebastian Kaebisch"
                , w3cid:      "43064"
                , company:    "Siemens AG"
                , companyURL: "https://www.siemens.com/"
                }
              , {
                  name:       "Takuki Kamiya"
                , w3cid:      "29376"
                , company:    "Fujitsu Laboratories of America, Inc."
                , companyURL: "https://www.fujitsu.com/"
                }
              ]
            , localBiblio: {
                "JSON-SCHEMA-VALIDATION": {
                  title:    "JSON Schema Validation: A Vocabulary for Structural Validation of JSON"
                , href:     "https://tools.ietf.org/html/draft-handrews-json-schema-validation-00"
                , authors: [
                    "Austin Wright"
                  , "Henry Andrews"
                  , "Geraint Luff"
                  ]
                , status:   "Internet-Draft"
                , publisher:  "IETF"
                }
              , "JSON-SCHEMA-CORE": {
                  title:    "JSON Schema: A Media Type for Describing JSON Documents"
                , href:     "https://tools.ietf.org/html/draft-handrews-json-schema-00"
                , authors:  [
                    "Austin Wright"
                  , "Henry Andrews"
                  ]
                , status:    "Internet-Draft"
                , publisher: "IETF"
                }
              , "WOT-ARCHITECTURE" : {
                  title: "Web of Things Architecture"
                , href: "https://w3c.github.io/wot-architecture/"
                , authors:  [
                    "Kazuo Kajimoto"
                  , "Matthias Kovatsch"
                  , "Uday Davuluru"
                  ]
                , publisher: "W3C"
                , date: "20 August 2017"
                }
	, "WOT-PROTOCOL-BINDING" : {
                  title: "Web of Things Protocol Binding Templates"
                , href: "https://w3c.github.io/wot-binding-templates/"
                , authors:  [
                    "Michael Koster"
                  ]
                , publisher: "W3C"
                , date: "12 January 2018"
                }
              }
            , otherLinks: [
                {
                  key: "Contributors"
                , data: [
                    {
                      value: "In the GitHub repository"
                    , href: "https://github.com/w3c/wot-thing-description/graphs/contributors"
                    }
                  ]
                }
              , {
                  key: "Repository",
                  data: [
                    {
                      value: "We are on GitHub"
                    , href: "https://github.com/w3c/wot-thing-description/"
                    }
                  , {
                      value: "File a bug"
                    , href: "https://github.com/w3c/wot-thing-description/issues"
                    }
                  ]
                }
              ]
            };
    </script>
<style>
.example {
		border-color: #EA1252;
		background: #FEF11E;
		counter-increment: example;
		overflow: auto;
		clear: both;
	}
</style>
  </head>
  <body>

  <section id="abstract">
This document describes a formal model and common representation for a Web of Things (WoT) Thing Description. A Thing Description describes the metadata and interfaces of Things, where a Thing is an abstraction of a physical entity that provides interactions to and participates in the Web of Things. Thing Descriptions provide a narrow-waist set of interactions based on a small vocabulary that makes it possible both to integrate diverse devices and to allow diverse applications to interoperate. Thing Descriptions, by default, are encoded in JSON-LD. JSON-LD provides both a powerful foundation to represent knowledge about Things and simplicity, since it allows processing as a JSON document. In addition to physical entities, Things can also represent virtual entities. A Thing Description instance can be hosted by the Thing itself or hosted externally due to Thing's resource restrictions (e.g. limited memory space) or when a Web of Things-compatible legacy device is retrofitted with a Thing Description.

<!-- for devices.
The TD must be acquired to use and interact with the Thing, since it describes the semantics of a Thing as well as its <a>WoT Interface</a>. Usually, Things directly provide their own TD, but the TD can also be hosted externally if there is not enough space on the device or when a WoT-compatible legacy device is retrofitted with a TD.-->
  </section>

  <section id="sotd">
  <p>
    Implementers need to be aware that this specification is considered unstable. Vendors interested in implementing this specification before it eventually reaches the Candidate Recommendation phase should subscribe to the [repository](https://github.com/w3c/wot-thing-description) and take part in the discussions.
  </p>

      <p class="ednote" title="The W3C WoT WG is asking for feedback">
        Please contribute to this draft using the <a href="https://github.com/w3c/wot-thing-description/issues">GitHub Issue</a> feature of the <a href="https://github.com/w3c/wot-thing-description/">WoT Thing Description</a> repository.
        For feedback on security and privacy considerations, please use the <a href="https://github.com/w3c/wot-security/issues">WoT Security and Privacy</a> Issues, as they are cross-cutting over all our documents.
      </p>

  </section>

  <section id="introduction">
    <h1>Introduction</h1>
    <p>
The W3C Thing Description (TD) is a central building block in a Web of Things (WoT) enabled system and can be considered as the entry point of a Thing (aka the <i>index.html</i> of the Thing). The TD consists of semantic metadata for the Thing itself, a narrow-waist interaction model with WoT's Properties, Actions, and Events, a semantic schema to make data models machine-understandable, and features for Web Linking to express relations among Things. 
</p>
<p>
Properties can be used for controlling (or retrieving) parameters, such as a setting an operation state (or getting the current value). Actions model invocation of physical processes, but can also be used to abstract RPC-like calls of existing platforms. Events cover the push model where state change notifications, discrete events, and streams of values are sent asynchronously to the receiver. In general, the TD provides metadata for the different communication bindings (e.g., HTTP, CoAP, MQTT, etc.), mediaTypes (e.g., "application/json", "application/xml", "application/cbor", "application/exi" etc.), and security policies (authentication, authorization, etc.). The default serialisation of the TD is JSON-LD.
</p>

<p>
Example 1 shows a simple TD instance that reflects WoT's Property, Action, Event paradigm by describing a lamp Thing with the name <i>MyLampThing</i>.
</p>

<pre class="example" title="Simple Thing Description Sample">
  {
    "@context": ["https://w3c.github.io/wot/w3c-wot-td-context.jsonld"],
    "@type": ["Thing"],
    "name": "MyLampThing",
    "interaction": [
        {
            "@type": ["Property"],
            "name": "status",
            "schema": {"type": "string"},
            "writable": false,
            "observable": true,
            "form": [{
                "href": "coaps://mylamp.example.com:5683/status",
                "mediaType": "application/json"
            }]
        },
        {
            "@type": ["Action"],
            "name": "toggle",
            "form": [{
                "href": "coaps://mylamp.example.com:5683/toggle",
                "mediaType": "application/json"
            }]
        },
        {
            "@type": ["Event"],
            "name": "overheating",
            "schema": {"type": "string"},
            "form": [{
                "href": "coaps://mylamp.example.com:5683/oh",
                "mediaType": "application/json"
            }]
        }
    ]
  }
 </pre>




<p>Based on this content, we know there exists one Property interaction resource with the name <i>status</i>. In addition, information is provided such as that this Property is accessable over the CoAP protocol with a GET method (see CoAP protocol binding description in the W3C WoT protocol template deliverable [[!WOT-PROTOCOL-BINDING]]) at coaps://mylamp.example.com:5683/status (announced within the <code>form</code> structure by the <code>href</code> key), which will return a string status value within a JSON structure (JSON as payload format is announced by the <code>mediaType</code> field).
</p>

<p>In a similar manner an Action is specified to toogle the switch status using the POST method that is applied to the coaps://mylamp.example.com:5683/toggle resource (see CoAP protocol binding description in the W3C WoT protocol template deliverable [[!WOT-PROTOCOL-BINDING]]).</p>

<p>Events which are, e.g., unexpected or irregular can be specified with the WoT's Event model. Here, a subscription of a possible overheating event of the lamp can be applied by using CoAP OBSERVE at coaps://mylamp.example.com:5683/oh. (see CoAP protocol binding description in the W3C WoT protocol template deliverable [[!WOT-PROTOCOL-BINDING]]).
</p>

<section id="intro-semantics"> 
<h1>Context Extensions</h1>
The Thing Description provides the oppertunity to have .



<p class="ednote">
Simple example with semantic usage should be introduce here as well.
</p>
</section>
</section>

<section id="terminology"> 
    <h2>Terminology</h2>
<p>The generic WoT terminology is defined in [[!WOT-ARCHITECTURE]]: <dfn data-lt="Things">Thing</dfn>, <dfn data-lt="Thing Descriptions">Thing Description</dfn> (in short <dfn>TD</dfn>), <dfn>Web of Things</dfn> (in short <b><i>WoT</i></b>),  <dfn>WoT Interface</dfn> etc.
</p>
  </section>

  <section>
    <h1>Namespaces</h1>

<p>
The namespace for TD is http://www.w3.org/ns/td#. TD itself defines a minimal set of classes and properties of its own. A full set of namespaces and prefixes used in this document is shown in the table below.
</p>

<table id="namespacesTable">
  <thead><tr><th>Prefix</th><th>Namespace</th></tr></thead>
  <tbody>
     <tr><td>td</td><td>http://www.w3.org/ns/td#</td></tr>
     <tr><td>rdf</td><td>http://www.w3.org/1999/02/22-rdf-syntax-ns#</td></tr>
   <!-- <tr><td>rdfs</td><td>http://www.w3.org/2000/01/rdf-schema#</td></tr>
    <tr><td>xsd</td><td>http://www.w3.org/2001/XMLSchema#</td></tr> -->
  </tbody>
</table>


<p class="ednote">
ToDo: complete table 
</p>
</section>
<section>
    <h1>Conformance</h1>

<p>
  As well as sections marked as non-normative, all authoring guidelines, diagrams, examples,   and notes in this specification are non-normative. Everything else in this specification is
  normative.
</p>
<p>
  The key words <em title="MUST" class="rfc2119">MUST</em>, <em title="MUST NOT" class="rfc2119">MUST NOT</em>, <em title="REQUIRED" class="rfc2119">REQUIRED</em>, <em title="SHOULD" class="rfc2119">SHOULD</em>, <em title="SHOULD NOT" class="rfc2119">SHOULD NOT</em>, <em title="RECOMMENDED" class="rfc2119">RECOMMENDED</em>, <em title="MAY" class="rfc2119">MAY</em>,
  and <em title="OPTIONAL" class="rfc2119">OPTIONAL</em> in this specification are to be interpreted as described in [<cite><a href="#bib-RFC2119" class="bibref">RFC2119</a></cite>].
</p>

 
<p>
A Thing Description instance complies with this specification if it follows the normative statements in Section <a href="#vocabularyDefinitionSection" class="sec-ref"><span class="secno">5.</span> <span class="sec-title">Vocabulary Definition</span></a>.
</p>

<p>
In case of JSON-LD serializiation, a Thing Description instance in JSON-LD format complies with this specification if it follows the normative statements in Section <a href="#serialization" class="sec-ref"><span class="secno">6.</span> <span class="sec-title">Serialization</span></a>
</p>

 

<p class="issue">
We need to be more precise here: How to validate a TD? E.g., structure validation and/or RDF validation? Comments are welcome.
</p>

</section>



{vocabulary.template}

  <section>
    <h1>JSON-LD Serialization</h1>

<p>
  Thing Description instances are modeled on the classes defined in <a href="#vocabularyDefinitionSection" class="sec-ref"></a>, and they are serialized in <a href="https://www.w3.org/TR/json-ld/">JSON-LD</a> by default, using the vocabulary defined there when they are served at run-time.
  JSON-LD is a serialization format that adds a semantic layer on top of the JSON specification: the terms that appear in a JSON document
  should be associated with uniquely identified concepts from shared vocabularies. This principle is part of a set of practices to publish data
  on the Web called Linked Data, where concepts are usually identified with URIs and originate from RDF vocabularies.
</p>

      <!-- p class="ednote">Currently, JSON-LD is seen as baseline for TD serialization. In TD task force alternatives are evaluated.
      </p -->
  <section id="sec-thing-as-a-whole">
    <h1>Thing as a Whole</h1>

      <p>The JSON-LD representation for a Thing Description is a JSON object of which fields are defined below.</p>

      <table class="def">
        <thead>
          <tr>
            <th>Field Name</th>
            <th>JSON Construct</th>
            <th>Mandatory</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>@context</td>
            <td>array of strings</td>
            <td>yes</td>
            <td>The array MUST contain a string "https://w3c.github.io/wot/w3c-wot-td-context.jsonld". Also see below.</td>
          </tr>
          <tr>
            <td>@type</td>
            <td>array of strings</td>
            <td>no</td>
            <td>Gives annotations to the Thing</td>
          </tr>
          <tr>
            <td>name</td>
            <td>string</td>
            <td>yes</td>
            <td>Name of the Thing</td>
          </tr>
          <tr>
            <td>base</td>
            <td>string</td>
            <td>no</td>
            <td>Base URI for use in a Thing Description. If relative URIs are used within the <code>form</code> field (see <a href="#form-serialization" class="sec-ref"></a>), <code>base</code> MUST be present. </td>
          </tr>
          <tr>
            <td>interaction</td>
            <td>array of objects</td>
            <td>no</td>
            <td>See <a href="#interaction-resources" class="sec-ref"></a></td>
          </tr>
          <tr>
            <td>security</td>
            <td>array of objects</td>
            <td>no</td>
            <td>See <a href="#security-serialization" class="sec-ref"></a></td>
          </tr>
        </tbody>
      </table>

      <p>Each field in Thing class (see <a href="#thing" class="sec-ref"></a>) is represented by the namesake JSON field described in the above table.
      </p>

<p>
The  <code>@context</code> key is used to define Thing Description's context. All JSON key terms that are defined in the present document (also see <a href="#vocabularyDefinitionSection">Vocabulary Definition Section</a> ) have been put in an external context document, available at
  <code>https://www.w3.org/ns/td/w3c-wot-td-context.jsonld</code>. Each Thing Description instance in JSON-LD MUST have this context information enmbedded within an JSON array structure. Thus, a basic Thing Description would contain the following declaration:
</p>

  <pre class="example">
    {
      "@context": ["https://www.w3.org/ns/td/w3c-wot-td-context.jsonld"],
      ...
    }
  </pre>

<p>
  In case a single Thing Description instance involves several contexts, additional namespaces with prefixes can be extended to the <code>@context</code> array structure. This option proves relevant if one wants to extend the existing Thing Description context without modifying it. For instance:
</p>
  <pre class="example">
    {
      "@context": ["https://www.w3.org/ns/td/w3c-wot-td-context.jsonld",
                   {"sensor": "http://example.org/sensors#"}],
      ...
    }
  </pre>

      <!-- p>A Thing Description will provide some generic Thing metadata vocabularies (also see <a href="#thing">Thing vocabulary definition section</a>) that can be used, e.g., 
      to assign a name or what kind of base URI does a servient support.</p -->

      <p>
        <b>Note:</b> Besides these pre-defined terms in the Thing Description context, additional characteristics can be
        added to Thing level such as product ID, firmware version, location, etc. These terms should then appear in the context of the Thing <!-- (as detailed in <a href="#td-context"></a>) -->.
      </p>

      <p class="ednote">This note should be moved to the td-context-extension definition once we have a section for that. In there it should be also explained that a context is not necessary if you are working outside of the RDF model and if you handle a TD just as a simple JSON document.
      </p>

<p>
A sample TD snippet that relies on the defined fields above is given below:
</p>
  <pre class="example">
        {
          "@context": ["https://www.w3.org/ns/td/w3c-wot-td-context.jsonld"],
          "@type": ["Thing"],
          "name": "MyThing",
          "base": "coap://mything.example.com:5683/",
          "interaction": [
           ...
        }
   </pre>


      <p><b>Note:</b>For examples of full Thing Description, see <a href="#examples" class="sec-ref"></a>
      </p>

  </section>



  <section id="interaction-resources">
    <h1>Interaction Resources</h1>

    <p>
      An interaction in the context of the Web of Things is an exchange of data between a Web client and a Thing.
      This data can be either given as input by the client, returned as output by the Thing, or both.
      Three interaction patterns are defined: 
      <a href="#property-serialization">Property</a>, 
      <a href="#action-serialization">Action</a>, and 
      <a href="#event-serialization">Event</a>.
    </p>
  
    <section id="property-serialization">
      <h3>Property</h3>
  
      <p>
        The <code>Property</code> interaction definitions (also see <a href="#property">Property vocabulary definition section</a>) provides metadata for readable and/or writeable data that can be static (e.g., supported mode, rated output voltage, etc.) or 
        dynamic (e.g., current fill level of water, minimum recorded temperature, etc.).
        Shown below is an example of a <code>Property</code> interaction definition.
      </p>


      <pre class="example">
        {
          ...
          "interaction": [
            {
              "@type": ["Property"],
              "name": "temperature",
              "schema":{ "type": "number" },
              "writable": false,
              "observable": true,
              "form": [{
                "href" : "coap://mytemp.example.com:5683/temp",
                "mediaType": "application/json"
              }]
            },
          ...
        }
      </pre>

      <p>The JSON-LD representation for a <code>Property</code> interaction definition is a JSON object of which the fields are defined below.</p>

      <table class="def">
        <thead>
          <tr>
            <th>Field Name</th>
            <th>JSON Construct</th>
            <th>Mandatory</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>@type</td>
            <td>array of strings</td>
            <td>yes</td>
            <td>Gives one or more semantic annotations to the <code>Property</code> interaction. The array MUST start with a string "Property"</td>
          </tr>
          <tr>
            <td>name</td>
            <td>string</td>
            <td>yes</td>
            <td>Name of the Property</td>
          </tr>
          <tr>
            <td>schema</td>
            <td>object</td>
            <td>yes</td>
            <td>See <a href="#type-system" class="sec-ref"></a></td>
          </tr>
          <tr>
            <td>writable</td>
            <td>boolean</td>
            <td>yes</td>
            <td>a property is writable (=true) or not (=false)</td>
          </tr>
          <tr>
            <td>observable</td>
            <td>boolean</td>
            <td>yes</td>
            <td>a property is observable (=true) or not (=false)</td>
          </tr>
          <tr>
            <td>form</td>
            <td>array of objects</td>
            <td>no</td>
            <td>See <a href="#form-serialization" class="sec-ref"></a></td>
          </tr>
        </tbody>
      </table>

      <p>Each field in Property class (see <a href="#property" class="sec-ref"></a>) is represented by the namesake JSON field described in the above table.
      </p>

    </section>
  
    <section id="action-serialization">
      <h3>Action</h3>
  
      <p>
        The <code>Action</code> interaction pattern (also see <a href="#action">Action vocabulary definition section</a>) targets changes or processes on a Thing that take a certain time to complete (i.e., actions cannot be applied instantaneously like property writes).
        Examples include an LED fade in, moving a robot, brewing a cup of coffee, etc.
        Usually, ongoing Actions are modeled as Task resources, which are created when an Action invocation is received by the Thing.
      </p>
  
      <pre class="example">
        {
          ...
          "interaction": [
            {
              "@type": ["Action"],
              "name": "fadeIn",
              <i>"inputSchema":</i> { "type": "integer" },
              "form": [{
              	"href" : "coap://mytemp.example.com:5683/in",
              	"mediaType": "application/json"
              }]
            }
          ]
          ...
        }
      </pre>

      <p>JSON-LD representation for an <code>Action</code> interaction definition is a JSON object of which the fields are defined below.</p>

      <table class="def">
        <thead>
          <tr>
            <th>Field Name</th>
            <th>JSON Construct</th>
            <th>Mandatory</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>@type</td>
            <td>array of strings</td>
            <td>yes</td>
            <td>Gives one or more semantic annotations to the <code>Action</code> interaction. The array MUST start with a string "Action"</td>
          </tr>
          <tr>
            <td>name</td>
            <td>string</td>
            <td>yes</td>
            <td>Name of the Action</td>
          </tr>
          <tr>
            <td>outputSchema</td>
            <td>object</td>
            <td>no</td>
            <td>See <a href="#type-system" class="sec-ref"></a></td>
          </tr>
          <tr>
            <td>inputSchema</td>
            <td>object</td>
            <td>no</td>
            <td>See <a href="#type-system" class="sec-ref"></a></td>
          </tr>
          <tr>
            <td>form</td>
            <td>array of objects</td>
            <td>no</td>
            <td>See <a href="#form-serialization" class="sec-ref"></a></td>
          </tr>
        </tbody>
      </table>

      <p>Each field in Action class (see <a href="#action" class="sec-ref"></a>) is represented by the namesake JSON field described in the above table.
      </p>

    </section>
  
    <section id="event-serialization">
      <h3>Event</h3>
  
      <p>
        The <code>Event</code> interaction pattern (also see <a href="#event">Event vocabulary definition section</a>) enables a mechanism to be notified by a Thing on a certain condition.
        While some protocols such as CoAP can provide such a mechanism natively, others do not.
        Furthermore, Events might need a specific configuration that requires data sent and stored on the Thing in a standard way.
        There are are four mandatory terms defined within the <code>Event</code> pattern:
      </p>
  
      <pre class="example">

        {
          ...
          "interaction": [
            {
              "@type": ["Event"],
              "name": "criticalCondition",
              "schema":  { "type": "string" },
              "form": [{
              	"href" : "coap://mytemp.example.com:5683/ev",
              	"mediaType": "application/json"
              }]
            }
          ]
          ...
        }
      </pre>

    </section>

      <p>The JSON-LD representation for an <code>Event</code> interaction definition is a JSON object of which the fields are defined below.</p>

      <table class="def">
        <thead>
          <tr>
            <th>Field Name</th>
            <th>JSON Construct</th>
            <th>Mandatory</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>@type</td>
            <td>array of strings</td>
            <td>yes</td>
            <td>Gives one or more semantic annotations to the <code>Event</code> interaction. The array MUST start with a string "Event"</td>
          </tr>
          <tr>
            <td>name</td>
            <td>string</td>
            <td>yes</td>
            <td>Name of the Event</td>
          </tr>
          <tr>
            <td>schema</td>
            <td>object</td>
            <td>yes</td>
            <td>See <a href="#type-system" class="sec-ref"></a></td>
          </tr>
          <tr>
            <td>form</td>
            <td>array of objects</td>
            <td>no</td>
            <td>See <a href="#form-serialization" class="sec-ref"></a></td>
          </tr>
        </tbody>
      </table>

      <p>Each field in Event class (see <a href="#event" class="sec-ref"></a>) is represented by the namesake JSON field described in the above table.
      </p>

  </section>

    <section>
      <h2 id="form-serialization">Form</h2>

      <p>This section describes JSON-LD serialization for the instances of the <a href="#form" class="sec-ref"></a> class. Shown below is an example of a form definition.
      </p>

      <pre class="example">
        "form": [
          {
            "href" : "coap://mytemp.example.com:5683/temp",
            "mediaType": "application/json",
            "rel": "getProperty"
          }
        ]
      </pre>

      <p>JSON-LD representation for a web form definition is a JSON array with name "form". 
         Each item in the array is a JSON object that consists of two JSON fields as summarized below.
      </p>

      <table class="def">
        <thead>
          <tr>
            <th>Field Name</th>
            <th>JSON Construct</th>
            <th>Mandatory</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>href</td>
            <td>string</td>
            <td>yes</td>
            <td>URI. If a relative URI is given then this URI is relative to the MUST present base URI (see <a href="#sec-thing-as-a-whole" class="sec-ref"></a>).</td>
          </tr>
          <tr>
            <td>mediaType</td>
            <td>string</td>
            <td>yes</td>
            <td>Media type based on IANA</td>
          </tr>
          <tr>
            <td>rel</td>
            <td>string</td>
            <td>no</td>
            <td>Provides the expected result of performing the operation described by the form.</td>
          </tr>
        </tbody>
      </table>

      <p>The form field is used to pointing a URI to an instance of the interaction and descriptions of the protocol settings and options expected to be used between the client and server for the interaction. The different opportunities of the protocol settings (such as for HTTP, CoAP, MQTT, etc)  is described in [[!WOT-PROTOCOL-BINDING]]. 
      </p>

    </section>

  <section id="security-serialization">
    <h1>Security</h1>

<p>Shown below is an example of a security resource definition.</p>

<pre class="example">
  {
    ...
    "security": [{
      "cat": "token:jwt", 
      "alg":"HS256", 
      "as":"https://authority-issuing.org"
    }],
    ...
  }
</pre>

<p>In the above example, a JSON Web Token (JWT) type is assigned (<code>cat</code>), along with a corresponding hashing algorithm "HS256" (<code>alg</code>) and the issuing authority of the security token (<code>as</code>).</p>

      <p class="ednote">Consider the need for a context definition for the above example.
      </p>
  </section>



  <section>
    <h1>Type System</h1>

    <p>All three interaction types, <code>Property</code>, <code>Action</code>, and <code>Event</code>, include data schema definitions. Instances of the <code>Property</code> and <code>Event</code> interaction types each must define only one schema (i.e. <code>schema</code> field), which describes the data they expose, while instances of the <code>Action</code> interaction type can define different schemas for inputs (i.e. <code>inputSchema</code>) and outputs (i.e. <code>outputSchema</code>). In the case of a <code>Property</code> that allows for an update operation, the input data and the output data are defined by a single schema (<code>schema</code> field).

   <p>
	In this section, we define an abstract type system notation based on JSON-LD for describing the structure and datatypes for values of interaction types. While type system is designed to be compatible with JSON schema [[JSON-SCHEMA-CORE]] [[JSON-SCHEMA-VALIDATION]], it is intended to be encoding-neutral and integrates into the Linked Data vocabularies to allow semantic annotations. It can not only be directly translated into JSON schema, but also can be handily translated into XML Schema. Use of JSON-LD equips the type system with a way to associate data elements with citations and semantic concepts defined elsewhere. 
	</p>




    <section>
      <h4>Simple Data Definition</h4>



    <section>
      <h4>Simple Types</h4>

	<p>Within <code>schema</code>, <code>inputSchema</code> and <code>outputSchema</code> fields, simple type assignments can be done by using the <code>type</code> field that specifies one of the datatypes borrowed from [[JSON-SCHEMA-VALIDATION]]. Shown below is an example of an interaction snippet that carries a simple type definition <code>number</code> within <code>schema</code>.  

    <pre class="example">
            "schema": { "type": "number" }
    </pre>

JSON-LD representation for primitive data type definition is a JSON object of which the field is defined below.

      <table class="def">
        <thead>
          <tr>
            <th>Field Name</th>
            <th>JSON Construct</th>
            <th>Mandatory</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>type</td>
            <td>string</td>
            <td>yes</td>
            <td><p>The following type defintions are possible for simple type assignments:
	      <ul>
		<li>boolean</li>
		<li>integer</li>
		<li>number</li>
		<li>string</li>
		<li>null</li>
	      </ul>
		</p>
	   </td>
          </tr>
        </tbody>
      </table>


    <p>These type constructs are in parallel to those that are available in JSON schema. Therefore, serialization of data exchanged between servients is straightforward when it is in JSON format.
    </p>
    </section>
    

    <section>
      <h4>Restrictions</h4>
  <p>In order to make more precise data type defintions the TD also allows the usage of restrication terms borrowed from [[JSON-SCHEMA-VALIDATION]]. Consider the following <code>inputSchema</code> definition which defines the value to be an <code>integer</code> within the value range of [ 0 ... 255 ].
      </p>

      <pre class="example">
        "inputSchema": { 
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        }
      </pre>

The following table only display a small subset of the restriction terms defined in JSON Schema. Please check [[JSON-SCHEMA-VALIDATION]] for the full set of restrictions. 

      <table class="def">
        <thead>
          <tr>
            <th>Field Name</th>
            <th>JSON Construct</th>
            <th>Mandatory</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>minimum</td>
            <td>number</td>
            <td>no</td>
            <td>Specifies a minimum numeric value. Only applicable for associated <code>number</code> or <code>integer</code> types.
	   </td>
          </tr>
          <tr>
            <td>maximum</td>
            <td>number</td>
            <td>no</td>
            <td>Specifies a maximum numeric value. Only applicable for associated <code>number</code> or <code>integer</code> types.
	   </td>
          </tr>
          <tr>
            <td>minLength</td>
            <td>number</td>
            <td>no</td>
            <td>Minimum length of the string. Only applicable for associated <code>string</code> type.
	   </td>
          </tr>
          <tr>
            <td>maxLength</td>
            <td>number</td>
            <td>no</td>
            <td>Maximum length of the string. Only applicable for associated <code>string</code> type.
	   </td>
          </tr>
          <tr>
            <td>const</td>
            <td>any type</td>
            <td>no</td>
            <td>Provides a constand/default value.
	   </td>
          </tr>
          <tr>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>Check [[JSON-SCHEMA-VALIDATION]] for further type restrictions terms.
	   </td>
          </tr>
        </tbody>
      </table>
   </section>
    <section>
      <h4>Semantic Annotation</h4>

<p>Unlike in JSON Schema, the TD with JSON-LD serializiation allows a semantic annotation of data members of the types by using the <code>@type</code> key. The example below comes with a semantic annotation within <code>inputSchema</code> to privide its semantic context <i>DimmerData</i> that is defined in the <i>http://iotschema.org/</i> namespace.
</p>

      <pre class="example">
        {
          "@context": [
            "https://w3c.github.io/wot/w3c-wot-td-context.jsonld", 
            {"iot": "http://iotschema.org/"}
          ],
          ...
          "inputSchema": { 
            "type": "integer",
            "@type": ["iot:DimmerData" ],
            "minimum": 0,
            "maximum": 255,
          },
          ...
        }
</pre>



<p>JSON-LD representation for semantic annotation of simple type within <code>schema</code>, <code>inputSchema</code> and <code>outputSchema</code> fields is  defined below.</p>


      <table class="def">
        <thead>
          <tr>
            <th>Field Name</th>
            <th>JSON Construct</th>
            <th>Mandatory</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>@type</td>
            <td>array of strings</td>
            <td>no</td>
            <td>Gives one or more semantic annotations to the data member.  </td>
          </tr>
        </tbody>
      </table>

<p class="ednote">
ToDo: Provide information about JSON Schema validation with <code>@type</code>. 
</p>

   </section>

    <section>
      <h4>Runtime Data Serializiation</h4>

<p>Unless otherwise specified in the <code>form</code> field (also see [[!WOT-PROTOCOL-BINDING]]) the provided schema reflects the payload structure of the runtime data of the <code>Property</code>, <code>Action</code>, and <code>Event</code>. </p>

      <p>Let's consider the simple data type defintion as shown in Example 11. When the <code>integer</code> being exchanged is 184, data serialization in JSON format will look like the following:
      </p>

      <pre class="example">
        184
      </pre>

      <p>The snippet in the above example is a valid JSON document according to the syntax defined in [[!RFC7159]], which allows sending simple types in the root of the document. There is no need for wrapping a single value into an object.
      </p>

      <p>The same data (i.e. a number equal to 184) will look like the following when the data is exchanged in XML.
      </p>

      <pre class="example">
      		&lt;integer>184&lt;/integer>
      </pre>
    </section>
    </section>
  
    <section>
      <h4>Structured Data Definition</h4>
 
	
      <p>With the type system, it is also possible to define value types that have more than one literal value.
      The type system provides two distinct constructs to define a structure that can have multiple literal values. 
      One is the <code>object</code>, and the other one is the <code>array</code>. Both <code>object</code> and <code>array</code> are assigned as the value of <code>type</code> field in order to indicate the use of those constructs.
      </p>



      <section>
        <h5 id="type-system-object">Object</h5>


	<p>In order to avoid duplicate key definitions with different meanings in the context documents, <code>object</code> definitions take a form that is slightly different from that of [[JSON-SCHEMA-VALIDATION]]. The following highlights the differences.
	      <ul>
		<li>TD uses a JSON array with a name <code>field</code> instead of JSON Schema's <i>properties</i> of a JSON object</li>

		<li>Each object in a <code>field</code> array must contain the key <code>name</code> (corresponding to the field name of the specified JSON object), and <code>schema</code>, whose value must be a data schema as specified in the present section (recursive definition)</li>
	      </ul>
	</p>

<p>The following example shows a Thing Description <code>object</code> definiton using JSON-LD serializiation, in comparison with an equivalent JSON Schema object definition.
</p>



      <table class="def">
        <thead>
          <tr>
            <th>TD with JSON-LD <code>object</code> definition</th>
            <th>JSON Schema <code>object</code> definition</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
        <pre class="example">
          {
              "type": "object",
              "field": [{
                  "name": "id",
                  "schema": {
                      "type": "integer"
                  }
              }],
              "required": ["id"]
          }
        </pre>
	</td>
            <td>
        <pre class="example">
          {
              "type": "object",
              "properties": {
                  "id": {"type": "integer"}
              },
              "required": ["id"]
          }
        </pre>
	    </td>
          </tr>
        </tbody>
      </table> 


    
        <p>The following is an example <code>inputSchema</code> definition that declares the value to be an <code>object</code> consisting of
        two named literals  <code>brightness</code> (of type <code>integer</code>) and <code>name</code> (of type <code>string</code>)
        where <code>brightness</code> is required to be present.
        </p>
    
        <pre class="example">
          "inputSchema": {
              "type": "object",
              "field": [
                  {
                      "name": "brightness",
                      "schema": {
                          "type": "integer",
                          "@type": ["iot:DimmerData"],
                          "minimum": 0,
                          "maximum": 255
                      }
                  },
                  {
                      "name": "name",
                      "schema": {
                        "type": "string"
                      }
                  }
              ],
              "required": ["brightness"]
          }
        </pre>
    
 

      </section>
  
      <section>
        <h5 id="type-system-array">Array</h5>
    
        <p>Arrays follow again the same convention as defined in [[JSON-SCHEMA-VALIDATION]]. The following is an example value type  definition that defines the value to be an <code>array</code> that consists of
        exactly three number literals with each value within the range of [ 0 ... 2047 ].
        </p>
    
        <pre class="example">
          "inputSchema": {
              "type": "array",
              "items": {
                  "type" : "number",
                  "minimum": 0,
                  "maximum": 2047
              },
              "minItems" : 3,
              "maxItems" : 3
          }
        </pre>
 
    
    
      </section><!-- End of "JSON Array" -->

	<section>
        <h5>Runtime Data Serializiation</h5>

       <p>When the <code>id</code> number and the <code>name</code> string values being exchanged are 1314520 and "Web of Things", data serialization in JSON format will look like the following.
        </p>
    
        <pre class="example">
          {
            "id": 1314520,
            "name": "Web of Things"
          }
        </pre>
    
        <p>The above data will look the following when the data is exchanged in XML.
        </p>
    
        <pre class="example">
            &lt;object>
              &lt;id>
                &lt;integer>1314520&lt;/integer>
              &lt;/id>
              &lt;name>
                &lt;string>Web of Things&lt;/string>
              &lt;/name>
            &lt;/object>
        </pre>

        <p>In both JSON and XML serialization, values can appear in any order regardless of the order used in the <code>field</code> definition of the <code>object</code>.
        </p>




   
        <p>When the numbers being exchanged are 520, 184 and 1314, data serialization in JSON format will look like the following.
        </p>
    
        <pre class="example">
          [
            520,
            184,
            1314
          ]
        </pre>
    
        <p>The above data will look the following when the data is exchanged in XML.
        </p>
    
        <pre class="example">
            &lt;array>
              &lt;number>520&lt;/number>
              &lt;number>184&lt;/number>
              &lt;number>1314&lt;/number>
            &lt;/array>
        </pre>

	</section> <!-- End of "Runtime Serializiation" -->
  
    </section><!-- End of "Structured Data" -->
  
    <section>
    <h4>Mapping to XML Schema</h4>

      <p>In the previous section, examples showed what data whose value type is described using the type system
      look like when serialized to XML in parallel to corresponding JSON serializations.
      </p>

      <p>This section describes how type definitions described using the type system can be mapped to XML schema definitions by using the same examples.
      Given these type definitions, providing the mapping to XML schema allows XML tools to directly validate serialized XML data, for example.
      The XML structure for which this mapping is designed is based on EXI4JSON [[exi-for-json]].
      </p>

    <section>
      <h5>Object Definition to XML Schema</h5>

      <p>Shown below is the type system <code>object</code> definition given for the <code>inputSchema</code> in Section <a href="#type-system-object">Object</a>. The <code>object</code> consists of two named literals <code>id</code> (of type <code>integer</code>) and <code>name</code> (of type <code>string</code>) where <code>id</code> is required to be present.
      </p>

      <pre class="example">
        {
            "type": "object",
            "field": [
                {
                    "name": "id",
                    "schema": {
                      "type": "integer"
                    }
                },
                {
                    "name": "name",
                    "schema": {
                      "type": "string"
                    }
                }
            ],
            "required": ["id"]
        }
      </pre>

      <p>When the <code>object</code> is anonymous (i.e. it is the root, or participates in an <code>array</code> definition), 
      the above <code>object</code> definition transforms to the following XML Schema element definition.
      </p>

      <pre class="example">
        &lt;xs:element name="object" xmlns:xs="http://www.w3.org/2001/XMLSchema">
            &lt;xs:complexType>
                &lt;xs:all>
                    &lt;xs:element name="id">
                        &lt;xs:complexType>
                          &lt;xs:sequence>
                            &lt;xs:element name="integer" type="xs:integer" />
                          &lt;/xs:sequence>
                        &lt;/xs:complexType>
                    &lt;/xs:element>
                    &lt;xs:element name="name" minOccurs="0">
                        &lt;xs:complexType>
                          &lt;xs:sequence>
                            &lt;xs:element name="string" type="xs:string" />
                          &lt;/xs:sequence>
                        &lt;/xs:complexType>
                    &lt;/xs:element>
                &lt;/xs:all>
            &lt;/xs:complexType>
        &lt;/xs:element>
        </pre>
  
        <!-- p class="ednote">JSON schema <code>object</code> does NOT define any order. 
        Therefore, in order to capture the constraints of JSON schema <code>object</code>, 
        we need to use xsd:all constructs instead of xsd:sequence.
        </p -->
  
        <p>Otherwise (i.e. the <code>object</code> is a member of another <code>object</code> definition, thus has a name), 
        the <code>object</code> definition transforms to the following XML schema element definition.
        Note <code><i>$name</i></code> represents the name of the <code>object</code>, and needs to be replaced by the actual name of the <code>object</code>.
        </p>
  
        <pre class="example">
          &lt;xs:element name="<i>$name</i>" xmlns:xs="http://www.w3.org/2001/XMLSchema">
              &lt;xs:complexType>
                  &lt;xs:sequence>
                      &lt;xs:element name="object">
                          &lt;xs:complexType>
                              &lt;xs:all>
                                  &lt;xs:element name="id">
                                      &lt;xs:complexType>
                                        &lt;xs:sequence>
                                          &lt;xs:element name="integer" type="xs:integer" />
                                        &lt;/xs:sequence>
                                      &lt;/xs:complexType>
                                  &lt;/xs:element>
                                  &lt;xs:element name="name" minOccurs="0">
                                      &lt;xs:complexType>
                                        &lt;xs:sequence>
                                          &lt;xs:element name="string" type="xs:string" />
                                        &lt;/xs:sequence>
                                      &lt;/xs:complexType>
                                  &lt;/xs:element>
                              &lt;/xs:all>
                          &lt;/xs:complexType>
                      &lt;/xs:element>
                  &lt;/xs:sequence>
              &lt;/xs:complexType>
          &lt;/xs:element>
        </pre>
  
      </section><!-- End of "JSON Object Definition to XML Schema" -->

      <section>
        <h5>Array Definition to XML Schema</h5>

          <p>Shown below is the type system <code>array</code> definition given for the <code>inputSchema</code> in Section <a href="#type-system-array">Array</a>. 
          The <code>array</code> consists of exactly three number literals with each value within the value range of [ 0 ... 2047 ].</p>

        <pre class="example">
          {
              "type": "array",
              "items": {
                  "type" : "number",
                  "minimum": 0,
                  "maximum": 2047
              },
              "minItems" : 3,
              "maxItems" : 3
          }
        </pre>
  
        <p>When the <code>array</code> is anonymous (i.e. it is the root, or participates in another <code>array</code> definition), 
        the above <code>array</code> definition transforms to the following XML Schema element definition.
        </p>
  
        <pre class="example">
          &lt;xs:element name="array" xmlns:xs="http://www.w3.org/2001/XMLSchema">
              &lt;xs:complexType>
                  &lt;xs:sequence>
                      &lt;xs:element name="double" minOccurs="3" maxOccurs="3">
                          &lt;xs:simpleType name="minInclusive">
                              &lt;xs:restriction base="xs:double">
                                  &lt;xs:minInclusive value="0"/>
                                  &lt;xs:maxInclusive value="2047"/>
                              &lt;/xs:restriction>
                          &lt;/xs:simpleType>
                      &lt;/xs:element>
                  &lt;/xs:sequence>
              &lt;/xs:complexType>
          &lt;/xs:element>
        </pre>

        <p>Otherwise (i.e. the <code>array</code> is a member of an <code>object</code> definition, thus has a name), 
        the <code>array</code> definition transforms to the following XML schema element definition.
        Note <code><i>$name</i></code> represents the name of the <code>array</code>, and needs to be replaced by the actual name of the <code>array</code>.
        </p>

        <pre class="example">
          &lt;xs:element name="<i>$name</i>" xmlns:xs="http://www.w3.org/2001/XMLSchema">
              &lt;xs:complexType>
                  &lt;xs:sequence>
                      &lt;xs:element name="array">
                          &lt;xs:complexType>
                              &lt;xs:sequence>
                                  &lt;xs:element name="double" minOccurs="3" maxOccurs="3" >
                                      &lt;xs:simpleType name="minInclusive">
                                          &lt;xs:restriction base="xs:double">
                                              &lt;xs:minInclusive value="0"/>
                                              &lt;xs:maxInclusive value="2047"/>
                                          &lt;/xs:restriction>
                                      &lt;/xs:simpleType>
                                  &lt;/xs:element>
                              &lt;/xs:sequence>
                          &lt;/xs:complexType>
                      &lt;/xs:element>
                  &lt;/xs:sequence>
              &lt;/xs:complexType>
          &lt;/xs:element>
        </pre>
  
      </section><!-- End of "JSON Array Definition to XML Schema" -->

    </section><!-- End of "Mapping to XML Schema" -->


    </section><!-- End of "Mapping to XML Schema" -->

  <section>
    <h2>Parsing</h2>
<p>
To parse a valid Thing Description a simple JSON-based parser and tools can be used to retrieve the content. To validate and follow references to external context vocabulary, JSON-LD or RDF-based parsing tools and libraries are highly recommended.   
</p>
   </section>

  <section id="examples">
    <h2>Examples</h2>

    <p>
      In the following, we give examples of full TDs. The first one, a
      temperature sensor, shows how to define relations between Thing
      Properties. As a second example, we modeled
      an actuator (LED lamp) where Actions have all been characterized semantically,
      so that machines could unambiguously interpret them in an automated manner.
      At last, association between Things is shown by defining a master switch
      controlling other LED lamps.
    </p>

    <section>
      <h4>Temperature Sensor</h4>

      <pre class="example">
        {
          "@context": ["https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
                       "https://w3c.github.io/wot/w3c-wot-common-context.jsonld"],
          "@type": ["Sensor"],
          "name": "myTempSensor",
          "base" : "coap:///www.example.com:5683/temp/",
          "interaction": [
            {
              "@id": "val",
              "@type": ["Property","Temperature"],
              "reference": "threshold",
              "name": "myTemp",
              "schema":  { 
                "type": "number",
                "unit": "celsius" 
              },
              "writable": false,
              "observable": true,
              "form": [{
              	"href" : "val",
              	"mediaType": "application/json"
              }]
            }, 
            {
              "@id": "threshold",
              "@type": ["Property","Temperature"],
              "name": "myThreshold",
              "schema": { 
                "type": "number",
                "unit": "celsius" 
              },
              "writable": true,
             	"form": [{
              	"href" : "thr",
              	"mediaType": "application/json"
              }]
            },
            {
              "@type": ["Event"],
              "schema": { "type": "number" },
              "name": "myChange",
              "property": "temp",
              "form": [{
              	"href" : "val/changed",
              	"mediaType": "application/json"
              }]
            }, 
            {
              "@type": ["Event"],
              "schema":  { "type": "number" },
              "name": "myWarning",
              "form": [{
              	"href" : "val/high",
              	"mediaType": "application/json"
              }]
            }
          ]
        }
      </pre>

      <p>
        The Thing <code>myTempSensor</code> defines two Properties: <code>myTemp</code>
        and <code>myThreshold</code>. Both are defined as temperatures, with the same unit
        (<code>celsius</code>). A client that is able to parse a TD only needs to know
        the predicate <code>reference</code> to understand that the threshold acts as
        a reference value for <code>myTemp</code> while the latter is the actual
        value measured by the temperature sensor. Here, <code>reference</code> points
        to <code>http://schema.org/valueReference</code>.
      </p>

      <p>
        Moreover, one of the Events of the Thing is linked to the measured value
        (with the predicate <code>property</code>). It means
        in that context that an event should be triggered each time <code>myTemp</code>
        changes. The other Event does not define further semantics. It could be used either
        in a closed system (where clients are aware of its meaning) or by a human but
        an external agent would not have sufficient information to interpret it.
      </p>
    </section>
    <section>
      <h4>LED Master Switch</h4>
      <pre class="example">
        {
          "@context": ["https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
                       "https://w3c.github.io/wot/w3c-wot-common-context.jsonld"],
          "@type": ["Lamp"],
          "name": "myMasterLED",
          "interaction": [
            {
              "@type": ["Action", "Toggle"],
              "name": "myMasterOnOff",
              "inputSchema": {
                "@type": "OnOff",
                "type": "boolean"
              },
              "form": [
                {
                  "href" : "coap://www.example.com:5683/master",
                  "mediaType": "application/json"
                },
                {
                  "href" : "http://www.example.com:80/master",
                  "mediaType": "application/json"
                }
              ]
            }
          ]
        }
      </pre>

      <p class="ednote"> 
       In this last example, it would be good to illustrate the use of <code>associations</code>.
        The Thing we modeled here acts as a master switch for eight lamps similar
        to that of <a href="#led-actuator"></a>. This means switching on and off
        <code>myMasterOnOff</code> will propagate to all associated Things
        by toggling their Action that is also of type <code>Toggle</code>.
        No precise semantics for <code>associations</code> have been defined yet
        and there might exist many other kinds of dependency between Things than
        simply parent/child relations. This issue will be addressed soon. Until then,
        Thing associations could be useful for discovery.
      </p>




  </section>
  </section>
 
  </section>
    
<section id="security-consideration">
      <h4>Security and Privacy Considerations</h4>
<p class="ednote">
  Please see the
  <a href="https://github.com/w3c/wot-security/">WoT Security and Privacy</a>
  repository for work in progress regarding threat models, assets, risks, 
  recommended mitigations, and best practices for security and privacy for systems 
  using the Web of Things.
  Once complete, security and privacy considerations relevant to Thing Descriptions will 
  be summarized in this section.
</p>
 </section>

<section   id="acknowledgements" class="appendix normative">
<h1>Acknowledgements</h1>
<p>This document contains a significant contribution from Web of Things members: ...</p>
</section>

  </body>
</html>
